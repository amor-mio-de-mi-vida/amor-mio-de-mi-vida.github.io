<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="amor mío de mi vida">
    
    <title>
        
            c++标准库 |
        
        Hesen's Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/avatar.svg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en","path":"search.xml"}
    KEEP.theme_config = {"title":"Keep","subtitle":"Hexo theme keep quick starter","description":"","keywords":null,"author":"Keep Team","language":"en","timezone":"","url":"http://example.com","permalink":":year/:month/:day/:name/","permalink_defaults":null,"pretty_urls":{"trailing_index":true,"trailing_html":true},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":"","wrap":true,"hljs":false},"prismjs":{"enable":false,"preprocess":true,"line_number":true,"tab_replace":""},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"meta_generator":true,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","updated_option":"mtime","per_page":10,"pagination_dir":"page","include":null,"exclude":null,"ignore":null,"theme":"keep","deploy":{"type":""},"search":{"path":"search.json","field":"post","content":true,"format":"striptags"},"feed":{"type":"atom","path":"atom.xml","limit":20},"math":{"perpage":true,"mathjax":{"enable":true,"mhchem":false}},"root":"","base_info":{"primary_color":"#0066cc","title":"Hesen's Blog","author":"amor mío de mi vida","avatar":"/images/avatar.svg","logo":"/images/avatar.svg","favicon":"/images/avatar.svg"},"menu":{"home":"/                       || fa-solid fa-home","archives":"/archives           || fa-solid fa-box-archive","tags":"/tags                   || fa-solid fa-tags","categories":"/categories       || fa-solid fa-layer-group","about":"/about                 || fa-solid fa-user","github":"https://github.com/amor-mio-de-mi-vida || fa-brands fa-github"},"first_screen":{"enable":true,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Audentis fortuna iuvat.","hitokoto":false},"social_contact":{"enable":true,"links":{"github":"https://github.com/amor-mio-de-mi-vida","weixin":"img |","qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":true,"hide_header":true},"home":{"announcement":null,"category":true,"tag":true,"post_datetime":"updated"},"post":{"author_badge":{"enable":true,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":true,"min2read":true},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":true,"share":true,"reward":{"enable":false,"img_link":null,"text":null}},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":true,"site_pv":true,"page_pv":true}},"local_search":{"enable":true,"preload":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.36"},"waline":{"server_url":null,"reaction":false,"version":"3.2.1"},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":true},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":true},"footer":{"since":2020,"word_count":false,"site_deploy":{"enable":false,"provider":"github","url":null},"record":{"enable":false,"list":[{"code":null,"link":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"source_data":{},"version":"4.2.3"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original post title","author":"Original post author","link":"Original post link"}
  </script>
<meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left flex-start border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/avatar.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               Hesen's Blog
            </a>
        </div>

        <div class="right border-box">
            <div class="pc border-box">
                <ul class="menu-list border-box">
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-home"></i>
                                
                                HOME
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/archives">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-box-archive"></i>
                                
                                ARCHIVES
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/tags">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-tags"></i>
                                
                                TAGS
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/categories">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-layer-group"></i>
                                
                                CATEGORIES
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/about">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-user"></i>
                                
                                ABOUT
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" target="_blank" rel="noopener" href="https://github.com/amor-mio-de-mi-vida">
                                
                                    <i class="menu-text-color menu-icon fa-brands fa-github"></i>
                                
                                GITHUB
                                
                            </a>
                            
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="menu-text-color fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile border-box flex-start">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list border-box">
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-home"></i>
                                </span>
                            
                            HOME
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/archives">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-box-archive"></i>
                                </span>
                            
                            ARCHIVES
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/tags">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-tags"></i>
                                </span>
                            
                            TAGS
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/categories">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-layer-group"></i>
                                </span>
                            
                            CATEGORIES
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/about">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-user"></i>
                                </span>
                            
                            ABOUT
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" target="_blank" rel="noopener" href="https://github.com/amor-mio-de-mi-vida">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-brands fa-github"></i>
                                </span>
                            
                            GITHUB
                        </a>
                        
                    </label>
                    
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        c++标准库
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/avatar.svg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">amor mío de mi vida</span>
                                
                                    <span class="author-badge">Lv4</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-11-20 09:01:49</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Wed Nov 20 2024 09:20:37 GMT+0800">2024-11-20 09:20:37</span>
            </span>
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/oiwiki/">oiwiki</a></li>
                        
                    
                </ul>
            </span>
        

        
            <span class="post-tag meta-info-item border-box">
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/oiwiki/">oiwiki</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item post-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>15k Words</span>
            </span>
        
        
            <span class="meta-info-item post-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>62 Mins</span>
            </span>
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <p>引用链接：</p>
<p><a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/">OI Wiki - OI Wiki<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/sevenjoin/article/details/88420885">C++
tuple元组的基本用法(总结)-CSDN博客<i class="fas fa-external-link-alt"></i></a> <span id="more"></span></p>
<h1 id="stl容器">STL容器</h1>
<h2 id="分类">分类</h2>
<figure>
<img lazyload="" alt="Pasted-image-20241119141514" data-src="https://github.com/amor-mio-de-mi-vida/picx-images-hosting/raw/master/其他/Pasted-image-20241119141514.4xukj1c2hv.webp">
<figcaption aria-hidden="true">Pasted-image-20241119141514</figcaption>
</figure>
<h3 id="序列式容器">序列式容器</h3>
<ul>
<li><p><strong>向量</strong>(<code>vector</code>)
后端可高效增加元素的顺序表。</p></li>
<li><p><strong>数组</strong>(<code>array</code>)<strong>C++11</strong>，定长的顺序表，C
风格数组的简单包装。</p></li>
<li><p><strong>双端队列</strong>(<code>deque</code>)
双端都可高效增加元素的顺序表。</p></li>
<li><p><strong>列表</strong>(<code>list</code>)
可以沿双向遍历的链表。</p></li>
<li><p><strong>单向列表</strong>(<code>forward_list</code>)
只能沿一个方向遍历的链表。</p></li>
</ul>
<h3 id="关联式容器">关联式容器</h3>
<ul>
<li><p><strong>集合</strong>(<code>set</code>)
用以有序地存储&nbsp;<strong>互异</strong>&nbsp;元素的容器。其实现是由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种比较元素大小的谓词进行排列。</p></li>
<li><p><strong>多重集合</strong>(<code>multiset</code>)
用以有序地存储元素的容器。允许存在相等的元素。</p></li>
<li><p><strong>映射</strong>(<code>map</code>) 由 {键，值}
对组成的集合，以某种比较键大小关系的谓词进行排列。</p></li>
<li><p><strong>多重映射</strong>(<code>multimap</code>) 由 {键，值}
对组成的多重集合，亦即允许键有相等情况的映射。</p></li>
</ul>
<h3 id="无序关联式容器">无序(关联式)容器</h3>
<ul>
<li><p><strong>无序（多重）集合</strong>(<code>unordered_set</code>/<code>unordered_multiset</code>)<strong>C++11</strong>，与&nbsp;<code>set</code>/<code>multiset</code>&nbsp;的区别在于元素无序，只关心「元素是否存在」，使用哈希实现。</p></li>
<li><p><strong>无序（多重）映射</strong>(<code>unordered_map</code>/<code>unordered_multimap</code>)<strong>C++11</strong>，与&nbsp;<code>map</code>/<code>multimap</code>&nbsp;的区别在于键
(key) 无序，只关心 "键与值的对应关系"，使用哈希实现。</p></li>
</ul>
<h3 id="容器适配器">容器适配器</h3>
<p>容器适配器其实并不是容器。它们不具有容器的某些特点（如：有迭代器、有&nbsp;<code>clear()</code>&nbsp;函数……）。</p>
<ul>
<li><p><strong>栈</strong>(<code>stack</code>) 后进先出 (LIFO)
的容器，默认是对双端队列（<code>deque</code>）的包装。</p></li>
<li><p><strong>队列</strong>(<code>queue</code>) 先进先出 (FIFO)
的容器，默认是对双端队列（<code>deque</code>）的包装。</p></li>
<li><p><strong>优先队列</strong>(<code>priority_queue</code>)
元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列，默认是对向量（<code>vector</code>）的包装。</p></li>
</ul>
<p>容器都是&nbsp;<code>containerName&lt;typeName,...&gt; name</code>&nbsp;的形式，但模板参数（<code>&lt;&gt;</code>&nbsp;内的参数）的个数、形式会根据具体容器而变。</p>
<h3 id="共有函数">共有函数</h3>
<p><code>=</code>：有赋值运算符以及复制构造函数。</p>
<p><code>begin()</code>：返回指向开头元素的迭代器。</p>
<p><code>end()</code>：返回指向末尾的下一个元素的迭代器。<code>end()</code>&nbsp;不指向某个元素，但它是末尾元素的后继。</p>
<p><code>size()</code>：返回容器内的元素个数。</p>
<p><code>max_size()</code>：返回容器&nbsp;<strong>理论上</strong>&nbsp;能存储的最大元素个数。依容器类型和所存储变量的类型而变。</p>
<p><code>empty()</code>：返回容器是否为空。</p>
<p><code>swap()</code>：交换两个容器。</p>
<p><code>clear()</code>：清空容器。</p>
<p><code>==</code>/<code>!=</code>/<code>&lt;</code>/<code>&gt;</code>/<code>&lt;=</code>/<code>&gt;=</code>：按&nbsp;<strong>字典序</strong>&nbsp;比较两个容器的大小。（比较元素大小时&nbsp;<code>map</code>&nbsp;的每个元素相当于&nbsp;<code>set&lt;pair&lt;key, value&gt;&gt;</code>，无序容器不支持&nbsp;<code>&lt;</code>/<code>&gt;</code>/<code>&lt;=</code>/<code>&gt;=</code>。）</p>
<h2 id="序列式容器-1">序列式容器</h2>
<h3 id="vector"><code>vector</code></h3>
<p><code>std::vector</code>&nbsp;是 STL
提供的&nbsp;<strong>内存连续的</strong>、<strong>可变长度</strong>&nbsp;的数组（亦称列表）数据结构。能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。</p>
<h4 id="构造方法">构造方法</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建空vector; 常数复杂度 </span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v0; </span><br><span class="line"><span class="comment">// 1+. 这句代码可以使得向vector中插入前3个元素时，保证常数时间复杂度 </span></span><br><span class="line">v<span class="number">0.</span><span class="built_in">reserve</span>(<span class="number">3</span>); </span><br><span class="line"><span class="comment">// 2. 创建一个初始空间为3的vector，其元素的默认值是0; 线性复杂度 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">3</span>)</span></span>; </span><br><span class="line"><span class="comment">// 3. 创建一个初始空间为3的vector，其元素的默认值是2; 线性复杂度 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">3</span>, <span class="number">2</span>)</span></span>; </span><br><span class="line"><span class="comment">// 4. 创建一个初始空间为3的vector，其元素的默认值是1， 并且使用v2的空间配置器; 线性复杂度 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">3</span>, <span class="number">1</span>, v<span class="number">2.</span>get_allocator())</span></span>; </span><br><span class="line"><span class="comment">// 5. 创建一个v2的拷贝vector v4， 其内容元素和v2一样; 线性复杂度 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v2)</span></span>; </span><br><span class="line"><span class="comment">// 6. 创建一个v4的拷贝vector v5，其内容是{v4[1], v4[2]}; 线性复杂度 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v5</span><span class="params">(v<span class="number">4.</span>begin() + <span class="number">1</span>, v<span class="number">4.</span>begin() + <span class="number">3</span>)</span></span>; </span><br><span class="line"><span class="comment">// 7. 移动v2到新创建的vector v6，不发生拷贝; 常数复杂度; 需要 C++11 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v6</span><span class="params">(std::move(v2))</span></span>; <span class="comment">// 或者 v6 = std::move(v2);</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="元素访问">元素访问</h4>
<p><code>vector</code>&nbsp;提供了如下几种方法进行元素访问</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>at()</code></td>
<td><code>v.at(pos)</code>&nbsp;返回容器中下标为&nbsp;<code>pos</code>&nbsp;的引用。如果数组越界抛出<code>std::out_of_range</code>&nbsp;类型的异常。</td>
</tr>
<tr>
<td><code>operator[]</code></td>
<td><code>v[pos]</code>&nbsp;返回容器中下标为&nbsp;<code>pos</code>&nbsp;的引用。不执行越界检查。</td>
</tr>
<tr>
<td><code>front()</code></td>
<td><code>v.front()</code>&nbsp;返回首元素的引用。</td>
</tr>
<tr>
<td><code>back()</code></td>
<td><code>v.back()</code>&nbsp;返回末尾元素的引用。</td>
</tr>
<tr>
<td><code>data()</code></td>
<td><code>v.data()</code>&nbsp;返回指向数组第一个元素的指针。</td>
</tr>
</tbody>
</table>
<h4 id="迭代器">迭代器</h4>
<p>vector 提供了如下几种&nbsp;迭代器</p>
<table>
<colgroup>
<col style="width: 35%">
<col style="width: 64%">
</colgroup>
<thead>
<tr>
<th>迭代器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin()/cbegin()</code></td>
<td>返回指向首元素的迭代器，其中&nbsp;<code>*begin = front</code>。</td>
</tr>
<tr>
<td><code>end()/cend()</code></td>
<td>返回指向数组尾端占位符的迭代器，注意是没有元素的。</td>
</tr>
<tr>
<td><code>rbegin()/crbegin()</code></td>
<td>返回指向逆向数组的首元素的逆向迭代器，可以理解为正向容器的末元素。</td>
</tr>
<tr>
<td><code>rend()/crend()</code></td>
<td>返回指向逆向数组末元素后一位置的迭代器，对应容器首的前一个位置，没有元素。</td>
</tr>
</tbody>
</table>
<p>以上列出的迭代器中，含有字符&nbsp;<code>c</code>&nbsp;的为只读迭代器，你不能通过只读迭代器去修改&nbsp;<code>vector</code>&nbsp;中的元素的值。如果一个&nbsp;<code>vector</code>&nbsp;本身就是只读的，那么它的一般迭代器和只读迭代器完全等价。只读迭代器自
C++11 开始支持。</p>
<h4 id="长度">长度</h4>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 83%">
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>empty()</code></td>
<td>返回一个&nbsp;<code>bool</code>&nbsp;值，即&nbsp;<code>v.begin() == v.end()</code>，<code>true</code>&nbsp;为空，<code>false</code>&nbsp;为非空。</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回容器长度（元素数量），即&nbsp;<code>std::distance(v.begin(), v.end())</code>。</td>
</tr>
<tr>
<td><code>resize()</code></td>
<td>改变&nbsp;<code>vector</code>&nbsp;的长度，多退少补。补充元素可以由参数指定。</td>
</tr>
<tr>
<td><code>max_size()</code></td>
<td>返回容器的最大可能长度。</td>
</tr>
</tbody>
</table>
<h4 id="容量">容量</h4>
<table>
<colgroup>
<col style="width: 34%">
<col style="width: 66%">
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reserve()</code></td>
<td>使得&nbsp;<code>vector</code>&nbsp;预留一定的内存空间，避免不必要的内存拷贝。</td>
</tr>
<tr>
<td><code>capacity()</code></td>
<td>返回容器的容量，即不发生拷贝的情况下容器的长度上限。</td>
</tr>
<tr>
<td><code>shrink_to_fit()</code></td>
<td>使得&nbsp;<code>vector</code>&nbsp;的容量与长度一致，多退但不会少。</td>
</tr>
</tbody>
</table>
<h4 id="元素增删以及修改">元素增删以及修改</h4>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 79%">
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>clear()</code></td>
<td>清除所有元素</td>
</tr>
<tr>
<td><code>insert()</code></td>
<td>支持在某个迭代器位置插入元素、可以插入多个。<strong>复杂度与&nbsp;<code>pos</code>&nbsp;距离末尾长度成线性而非常数的</strong></td>
</tr>
<tr>
<td><code>erase()</code></td>
<td>删除某个迭代器或者区间的元素，返回最后被删除的迭代器。复杂度与&nbsp;<code>insert</code>&nbsp;一致。</td>
</tr>
<tr>
<td><code>push_back()</code></td>
<td>在末尾插入一个元素，均摊复杂度为&nbsp;<strong>常数</strong>，最坏为线性复杂度。</td>
</tr>
<tr>
<td><code>pop_back()</code></td>
<td>删除末尾元素，常数复杂度。</td>
</tr>
<tr>
<td><code>swap()</code></td>
<td>与另一个容器进行交换，此操作是&nbsp;<strong>常数复杂度</strong>&nbsp;而非线性的。</td>
</tr>
</tbody>
</table>
<h3 id="array-c11"><code>array (C++11)</code></h3>
<p><code>std::array</code>&nbsp;是 STL
提供的&nbsp;<strong>内存连续的</strong>、<strong>固定长度</strong>&nbsp;的数组数据结构。其本质是对原生数组的直接封装。</p>
<h4 id="隐式定义的成员函数">隐式定义的成员函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operator=</code></td>
<td>以来自另一&nbsp;<code>array</code>&nbsp;的每个元素重写&nbsp;<code>array</code>&nbsp;的对应元素</td>
</tr>
</tbody>
</table>
<h4 id="元素访问-1">元素访问</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>at</code></td>
<td>访问指定的元素，同时进行越界检查</td>
</tr>
<tr>
<td><code>operator[]</code></td>
<td>访问指定的元素，<strong>不</strong>&nbsp;进行越界检查</td>
</tr>
<tr>
<td><code>front</code></td>
<td>访问第一个元素</td>
</tr>
<tr>
<td><code>back</code></td>
<td>访问最后一个元素</td>
</tr>
<tr>
<td><code>data</code></td>
<td>返回指向内存中数组第一个元素的指针</td>
</tr>
</tbody>
</table>
<p><code>at</code>&nbsp;若遇&nbsp;<code>pos &gt;= size()</code>&nbsp;的情况会抛出&nbsp;<code>std::out_of_range</code>。</p>
<h4 id="容量-1">容量</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>empty</code></td>
<td>检查容器是否为空</td>
</tr>
<tr>
<td><code>size</code></td>
<td>返回容纳的元素数</td>
</tr>
<tr>
<td><code>max_size</code></td>
<td>返回可容纳的最大元素数</td>
</tr>
</tbody>
</table>
<p>由于每个&nbsp;<code>array</code>&nbsp;都是固定大小容器，<code>size()</code>&nbsp;返回的值等于&nbsp;<code>max_size()</code>&nbsp;返回的值。</p>
<h4 id="操作">操作</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fill</code></td>
<td>以指定值填充容器</td>
</tr>
<tr>
<td><code>swap</code></td>
<td>交换内容</td>
</tr>
</tbody>
</table>
<p><strong>注意，交换两个&nbsp;<code>array</code>&nbsp;是&nbsp;<img lazyload="" alt="image" data-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="\Theta(\text{size})">&nbsp;的，而非与常规 STL 容器一样为 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>。</strong></p>
<h4 id="非成员函数">非成员函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operator==</code>&nbsp;等</td>
<td>按照字典序比较&nbsp;<code>array</code>&nbsp;中的值</td>
</tr>
<tr>
<td><code>std::get</code></td>
<td>访问&nbsp;<code>array</code>&nbsp;的一个元素</td>
</tr>
<tr>
<td><code>std::swap</code></td>
<td>特化的&nbsp;<code>std::swap</code>&nbsp;算法</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建空array，长度为3; 常数复杂度 </span></span><br><span class="line">std::array&lt;<span class="type">int</span>, 3&gt; v0; </span><br><span class="line"><span class="comment">// 2. 用指定常数创建array; 常数复杂度 </span></span><br><span class="line">std::array&lt;<span class="type">int</span>, 3&gt; v1{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}; v<span class="number">0.f</span>ill(<span class="number">1</span>); <span class="comment">// 填充数组 </span></span><br><span class="line"><span class="comment">// 访问数组 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != arr.<span class="built_in">size</span>(); ++i) cout &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="deque"><code>deque</code></h3>
<p><code>std::deque</code>&nbsp;是 STL 提供的&nbsp;双端队列
数据结构。能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义一个int类型的空双端队列 v0 </span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; v0; </span><br><span class="line"><span class="comment">// 2. 定义一个int类型的双端队列 v1，并设置初始大小为10; 线性复杂度 </span></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>; </span><br><span class="line"><span class="comment">// 3. 定义一个int类型的双端队列 v2，并初始化为10个1; 线性复杂度 </span></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>; </span><br><span class="line"><span class="comment">// 4. 复制已有的双端队列 v1; 线性复杂度 </span></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(v1)</span></span>; </span><br><span class="line"><span class="comment">// 5. 创建一个v2的拷贝deque v4，其内容是v4[0]至v4[2]; 线性复杂度 </span></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v<span class="number">2.</span>begin(), v<span class="number">2.</span>begin() + <span class="number">3</span>)</span></span>; </span><br><span class="line"><span class="comment">// 6. 移动v2到新创建的deque v5，不发生拷贝; 常数复杂度; 需要 C++11 </span></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">v5</span><span class="params">(std::move(v2))</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="元素访问-2">元素访问</h4>
<p>与&nbsp;<code>vector</code>&nbsp;一致，但无法访问底层内存。其高效的元素访问速度可参考实现细节部分。</p>
<table>
<colgroup>
<col style="width: 26%">
<col style="width: 73%">
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>at()</code></td>
<td>返回容器中指定位置元素的引用，执行越界检查，<strong>常数复杂度</strong>。</td>
</tr>
<tr>
<td><code>operator[]</code></td>
<td>返回容器中指定位置元素的引用。不执行越界检查，<strong>常数复杂度</strong>。</td>
</tr>
<tr>
<td><code>front()</code></td>
<td>返回首元素的引用。</td>
</tr>
<tr>
<td><code>back()</code></td>
<td>返回末尾元素的引用。</td>
</tr>
</tbody>
</table>
<h4 id="迭代器-1">迭代器</h4>
<p>与&nbsp;<code>vector</code>&nbsp;一致。</p>
<h4 id="长度-1">长度</h4>
<p>与&nbsp;<code>vector</code>&nbsp;一致，但是没有&nbsp;<code>reserve()</code>&nbsp;和&nbsp;<code>capacity()</code>&nbsp;函数。（仍然有&nbsp;<code>shrink_to_fit()</code>&nbsp;函数）</p>
<h4 id="元素增删及修改">元素增删及修改</h4>
<p>与&nbsp;<code>vector</code>&nbsp;一致，并额外有向队列头部增加元素的函数。</p>
<table>
<colgroup>
<col style="width: 22%">
<col style="width: 77%">
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>clear()</code></td>
<td>清除所有元素</td>
</tr>
<tr>
<td><code>insert()</code></td>
<td>支持在某个迭代器位置插入元素、可以插入多个。<strong>复杂度与&nbsp;<code>pos</code>&nbsp;与两端距离较小者成线性</strong>。</td>
</tr>
<tr>
<td><code>erase()</code></td>
<td>删除某个迭代器或者区间的元素，返回最后被删除的迭代器。复杂度与&nbsp;<code>insert</code>&nbsp;一致。</td>
</tr>
<tr>
<td><code>push_front()</code></td>
<td>在头部插入一个元素，<strong>常数复杂度</strong>。</td>
</tr>
<tr>
<td><code>push_back()</code></td>
<td>在末尾插入一个元素，<strong>常数复杂度</strong>。</td>
</tr>
<tr>
<td><code>pop_back()</code></td>
<td>删除末尾元素，<strong>常数复杂度</strong>。</td>
</tr>
<tr>
<td><code>swap()</code></td>
<td>与另一个容器进行交换，此操作是&nbsp;<strong>常数复杂度</strong>&nbsp;而非线性的。</td>
</tr>
</tbody>
</table>
<h3 id="list"><code>list</code></h3>
<p><code>std::list</code>&nbsp;是 STL 提供的&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/ds/linked-list/">双向链表<i class="fas fa-external-link-alt"></i></a>&nbsp;数据结构。能够提供线性复杂度的随机访问，以及常数复杂度的插入和删除。</p>
<h4 id="元素访问-3">元素访问</h4>
<p>由于&nbsp;<code>list</code>&nbsp;的实现是链表，因此它不提供随机访问的接口。若需要访问中间元素，则需要使用迭代器。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>front()</code></td>
<td>返回首元素的引用。</td>
</tr>
<tr>
<td><code>back()</code></td>
<td>返回末尾元素的引用。</td>
</tr>
</tbody>
</table>
<h4 id="操作-1">操作</h4>
<p><code>list</code>&nbsp;类型还提供了一些针对其特性实现的 STL
算法函数。由于这些算法需要&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/lang/csl/iterator/">随机访问迭代器<i class="fas fa-external-link-alt"></i></a>，因此&nbsp;<code>list</code>&nbsp;提供了特别的实现以便于使用。这些算法有&nbsp;<code>splice()</code>、<code>remove()</code>、<code>sort()</code>、<code>unique()</code>、<code>merge()</code>&nbsp;等。</p>
<h3 id="forward_list"><code>forward_list</code></h3>
<p><code>std::forward_list</code>&nbsp;是 STL 提供的&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/ds/linked-list/">单向链表<i class="fas fa-external-link-alt"></i></a>&nbsp;数据结构，相比于&nbsp;<code>std::list</code>&nbsp;减小了空间开销。</p>
<p><code>forward_list</code>&nbsp;的使用方法与&nbsp;<code>list</code>&nbsp;几乎一致，但是迭代器只有单向的</p>
<h2 id="关联式容器-1">关联式容器</h2>
<h3 id="set"><code>set</code></h3>
<p><code>set</code>&nbsp;是关联容器，含有键值类型对象的已排序集，搜索、移除和插入拥有对数复杂度。<code>set</code>&nbsp;内部通常采用&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/ds/rbtree/">红黑树<i class="fas fa-external-link-alt"></i></a>&nbsp;实现。<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/ds/bst/">平衡二叉树<i class="fas fa-external-link-alt"></i></a>&nbsp;的特性使得&nbsp;<code>set</code>&nbsp;非常适合处理需要同时兼顾查找、插入与删除的情况。</p>
<p>和数学中的集合相似，<code>set</code>&nbsp;中不会出现值相同的元素。如果需要有相同元素的集合，需要使用&nbsp;<code>multiset</code>。<code>multiset</code>&nbsp;的使用方法与&nbsp;<code>set</code>&nbsp;的使用方法基本相同。</p>
<h4 id="插入与删除操作">插入与删除操作</h4>
<table>
<colgroup>
<col style="width: 37%">
<col style="width: 62%">
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>insert(x)</code></td>
<td>当容器中没有等价元素的时候，将元素 x
插入到&nbsp;<code>set</code>&nbsp;中。</td>
</tr>
<tr>
<td><code>erase(x)</code></td>
<td>删除值为 x 的&nbsp;<strong>所有</strong>&nbsp;元素，返回删除元素的个数。</td>
</tr>
<tr>
<td><code>erase(pos)</code></td>
<td>删除迭代器为 pos 的元素，要求迭代器必须合法。</td>
</tr>
<tr>
<td><code>erase(first,last)</code></td>
<td>删除迭代器在&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.187ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4944.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(828,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1173,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1624,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(2093,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(2454,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2898.7,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(3196.7,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(3725.7,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(4194.7,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(4555.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>&nbsp;范围内的所有元素。</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空&nbsp;<code>set</code>。</td>
</tr>
</tbody>
</table>
<p>insert
函数的返回值类型为&nbsp;<code>pair&lt;iterator, bool&gt;</code>，其中
iterator
是一个指向所插入元素（或者是指向等于所插入值的原本就在容器中的元素）的迭代器，而
bool
则代表元素是否插入成功，由于&nbsp;<code>set</code>&nbsp;中的元素具有唯一性质，所以如果在&nbsp;<code>set</code>&nbsp;中已有等值元素，则插入会失败，返回
false，否则插入成功，返回 true；<code>map</code>&nbsp;中的 insert
也是如此。</p>
<h4 id="迭代器-2">迭代器</h4>
<p><code>set</code>&nbsp;提供了以下几种迭代器：</p>
<table>
<colgroup>
<col style="width: 35%">
<col style="width: 64%">
</colgroup>
<thead>
<tr>
<th>迭代器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin()/cbegin()</code></td>
<td>返回指向首元素的迭代器，其中&nbsp;<code>*begin = front</code>。</td>
</tr>
<tr>
<td><code>end()/cend()</code></td>
<td>返回指向数组尾端占位符的迭代器，注意是没有元素的。</td>
</tr>
<tr>
<td><code>rbegin()/crbegin()</code></td>
<td>返回指向逆向数组的首元素的逆向迭代器，可以理解为正向容器的末元素。</td>
</tr>
<tr>
<td><code>rend()/crend()</code></td>
<td>返回指向逆向数组末元素后一位置的迭代器，对应容器首的前一个位置，没有元素。</td>
</tr>
</tbody>
</table>
<p>以上列出的迭代器中，含有字符&nbsp;<code>c</code>&nbsp;的为只读迭代器，你不能通过只读迭代器去修改&nbsp;<code>set</code>&nbsp;中的元素的值。如果一个&nbsp;<code>set</code>&nbsp;本身就是只读的，那么它的一般迭代器和只读迭代器完全等价。只读迭代器自
C++11 开始支持。</p>
<h4 id="查找操作">查找操作</h4>
<table>
<colgroup>
<col style="width: 26%">
<col style="width: 73%">
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>count(x)</code></td>
<td>返回&nbsp;<code>set</code>&nbsp;内键为 x 的元素数量。</td>
</tr>
<tr>
<td><code>find(x)</code></td>
<td>在&nbsp;<code>set</code>&nbsp;内存在键为 x
的元素时会返回该元素的迭代器，否则返回&nbsp;<code>end()</code>。</td>
</tr>
<tr>
<td><code>lower_bound(x)</code></td>
<td>返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，返回&nbsp;<code>end()</code>。</td>
</tr>
<tr>
<td><code>upper_bound(x)</code></td>
<td>返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，返回&nbsp;<code>end()</code>。</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>返回容器是否为空。</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回容器内元素个数。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>lower_bound</code>&nbsp;和&nbsp;<code>upper_bound</code>&nbsp;的时间复杂度</p>
<p><code>set</code>&nbsp;自带的&nbsp;<code>lower_bound</code>&nbsp;和&nbsp;<code>upper_bound</code>&nbsp;的时间复杂度为&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.112ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3585.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(2430,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(2596.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3196.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>。</p>
<p>但使用&nbsp;<code>algorithm</code>&nbsp;库中的&nbsp;<code>lower_bound</code>&nbsp;和&nbsp;<code>upper_bound</code>&nbsp;函数对&nbsp;<code>set</code>&nbsp;中的元素进行查询，时间复杂度为&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>。</p>
</blockquote>
<blockquote>
<p><code>nth_element</code>&nbsp;的时间复杂度</p>
<p><code>set</code>&nbsp;没有提供自带的&nbsp;<code>nth_element</code>。使用&nbsp;<code>algorithm</code>&nbsp;库中的&nbsp;<code>nth_element</code>&nbsp;查找第&nbsp;<img lazyload="" alt="image" data-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="k">&nbsp;大的元素时间复杂度为&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>。</p>
<p>如果需要实现平衡二叉树所具备的&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.112ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3585.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(2430,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(2596.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3196.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>&nbsp;查找第&nbsp;<img lazyload="" alt="image" data-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="k">&nbsp;大元素的功能，需要自己手写平衡二叉树或权值线段树，或者选择使用
<code>pb_ds</code> 库中的平衡二叉树。</p>
</blockquote>
<h4 id="使用样例">使用样例</h4>
<p>在贪心算法中经常会需要出现类似&nbsp;<strong>找出并删除最小的大于等于某个值的元素</strong>。这种操作能轻松地通过&nbsp;<code>set</code>&nbsp;来完成。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现存可用的元素 </span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; available; </span><br><span class="line"><span class="comment">// 需要大于等于的值 </span></span><br><span class="line"><span class="type">int</span> x; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找最小的大于等于x的元素 </span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it = available.<span class="built_in">lower_bound</span>(x); </span><br><span class="line"><span class="keyword">if</span> (it == available.<span class="built_in">end</span>()) { </span><br><span class="line">	<span class="comment">// 不存在这样的元素，则进行相应操作…… </span></span><br><span class="line">	} <span class="keyword">else</span> { </span><br><span class="line">	<span class="comment">// 找到了这样的元素，将其从现存可用元素中移除 </span></span><br><span class="line">	available.<span class="built_in">erase</span>(it); </span><br><span class="line">	<span class="comment">// 进行相应操作…… </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="map"><code>map</code></h3>
<p><code>map</code>&nbsp;是有序键值对容器，它的元素的键是<strong>唯一</strong>的。搜索、移除和插入操作拥有对数复杂度。<code>map</code>&nbsp;通常实现为&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/ds/rbtree/">红黑树<i class="fas fa-external-link-alt"></i></a>。</p>
<p>设想如下场景：现在需要存储一些键值对，例如存储学生姓名对应的分数：<code>Tom 0</code>，<code>Bob 100</code>，<code>Alan 100</code>。但是由于数组下标只能为非负整数，所以无法用姓名作为下标来存储，这个时候最简单的办法就是使用
STL 中的&nbsp;<code>map</code>。</p>
<p><code>map</code>&nbsp;重载了&nbsp;<code>operator[]</code>，可以用任意定义了&nbsp;<code>operator &lt;</code>&nbsp;的类型作为下标（在&nbsp;<code>map</code>&nbsp;中叫做&nbsp;<code>key</code>，也就是索引）：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;Key, T&gt; yourMap;</span><br></pre></td></tr></tbody></table></figure>
<p><code>map</code>&nbsp;中不会存在键相同的元素，<code>multimap</code>&nbsp;中允许多个元素拥有同一键。<code>multimap</code>&nbsp;的使用方法与&nbsp;<code>map</code>&nbsp;的使用方法基本相同。</p>
<blockquote>
<p>正是因为&nbsp;<code>multimap</code>&nbsp;允许多个元素拥有同一键的特点，<code>multimap</code>&nbsp;并没有提供给出键访问其对应值的方法。</p>
</blockquote>
<h4 id="插入与删除操作-1">插入与删除操作</h4>
<table>
<colgroup>
<col style="width: 18%">
<col style="width: 81%">
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operator[]</code></td>
<td>可以直接通过下标访问来进行查询或插入操作。例如&nbsp;<code>mp["Alan"]=100</code>。</td>
</tr>
<tr>
<td><code>insert(pair&lt;Key,T&gt;)</code></td>
<td>通过向&nbsp;<code>map</code>&nbsp;中插入一个类型为&nbsp;<code>pair&lt;Key, T&gt;</code>&nbsp;的值可以达到插入元素的目的，例如&nbsp;<code>mp.insert(pair&lt;string,int&gt;("Alan",100));</code>；</td>
</tr>
<tr>
<td><code>erase(key)</code></td>
<td>函数会删除键为&nbsp;<code>key</code>&nbsp;的&nbsp;<strong>所有</strong>&nbsp;元素。返回值为删除元素的数量。</td>
</tr>
<tr>
<td><code>erase(pos)</code></td>
<td>删除迭代器为 pos 的元素，要求迭代器必须合法。</td>
</tr>
<tr>
<td><code>erase(first,last)</code></td>
<td>删除迭代器在&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.187ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4944.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(828,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1173,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1624,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(2093,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(2454,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2898.7,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(3196.7,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(3725.7,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(4194.7,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(4555.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>&nbsp;范围内的所有元素。</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>函数会清空整个容器。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>在利用下标访问&nbsp;<code>map</code>&nbsp;中的某个元素时，如果&nbsp;<code>map</code>&nbsp;中不存在相应键的元素，会自动在&nbsp;<code>map</code>&nbsp;中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）。</p>
<p>当下标访问操作过于频繁时，容器中会出现大量无意义元素，影响&nbsp;<code>map</code>&nbsp;的效率。因此一般情况下推荐使用&nbsp;<code>find()</code>&nbsp;函数来寻找特定键的元素。</p>
</blockquote>
<h4 id="查询操作">查询操作</h4>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 79%">
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>count(x)</code></td>
<td>返回容器内键为 x 的元素数量。复杂度为&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="18.467ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 8162.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(2430,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mo" transform="translate(2430,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2819,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(3288,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(3633,0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g><g data-mml-node="mi" transform="translate(4098,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(4564,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5175.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(6175.4,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(6704.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(7304.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mo" transform="translate(7773.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>（关于容器大小对数复杂度，加上匹配个数）。</td>
</tr>
<tr>
<td><code>find(x)</code></td>
<td>若容器内存在键为 x
的元素，会返回该元素的迭代器；否则返回&nbsp;<code>end()</code>。</td>
</tr>
<tr>
<td><code>lower_bound(x)</code></td>
<td>返回指向首个不小于给定键的元素的迭代器。</td>
</tr>
<tr>
<td><code>upper_bound(x)</code></td>
<td>返回指向首个大于给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回&nbsp;<code>end()</code>。</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>返回容器是否为空。</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回容器内元素个数。</td>
</tr>
</tbody>
</table>
<h4 id="使用样例-1">使用样例</h4>
<p>在搜索中，我们有时需要存储一些较为复杂的状态（如坐标，无法离散化的数值，字符串等）以及与之有关的答案（如到达此状态的最小步数）。<code>map</code>&nbsp;可以用来实现此功能。其中的键是状态，而值是与之相关的答案。下面的示例展示了如何使用&nbsp;<code>map</code>&nbsp;存储以&nbsp;<code>string</code>&nbsp;表示的状态。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储状态与对应的答案 </span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; record; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 新搜索到的状态与对应答案 </span></span><br><span class="line">string status; <span class="type">int</span> ans; </span><br><span class="line"><span class="comment">// 查找对应的状态是否出现过 </span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::iterator it = record.<span class="built_in">find</span>(status); </span><br><span class="line"><span class="keyword">if</span> (it == record.<span class="built_in">end</span>()) { </span><br><span class="line">	<span class="comment">// 尚未搜索过该状态，将其加入状态记录中 </span></span><br><span class="line">	record[status] = ans; </span><br><span class="line">	<span class="comment">// 进行相应操作…… </span></span><br><span class="line">	} <span class="keyword">else</span> { </span><br><span class="line">	<span class="comment">// 已经搜索过该状态，进行相应操作…… </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="遍历容器">遍历容器</h4>
<p>可以利用迭代器来遍历关联式容器的所有元素。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="keyword">using</span> si = set&lt;<span class="type">int</span>&gt;::iterator;</span><br><span class="line"><span class="keyword">for</span> (si it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) </span><br><span class="line">	cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure>
<p>需要注意的是，对&nbsp;<code>map</code>&nbsp;的迭代器解引用后，得到的是类型为&nbsp;<code>pair&lt;Key, T&gt;</code>&nbsp;的键值对。</p>
<p>在 C++11 中，使用范围 for 循环会让代码简洁很多：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s; <span class="keyword">for</span> (<span class="keyword">auto</span> x : s) cout &lt;&lt; x &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure>
<p>对于任意关联式容器，使用迭代器遍历容器的时间复杂度均为 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.112ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3585.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(2430,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(2596.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3196.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span></p>
<h4 id="自定义比较方式">自定义比较方式</h4>
<p><code>set</code>&nbsp;在默认情况下的比较函数为&nbsp;<code>&lt;</code>（如果是非内置类型需要&nbsp;<a target="_blank" rel="noopener" href="https://oi-wiki.org/lang/op-overload/#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6">重载&nbsp;<code>&lt;</code>&nbsp;运算符</a>）。然而在某些特殊情况下，我们希望能自定义&nbsp;<code>set</code>&nbsp;内部的比较方式。</p>
<p>这时候可以通过传入自定义比较器来解决问题。</p>
<p>具体来说，我们需要定义一个类，并在这个类中&nbsp;<a target="_blank" rel="noopener" href="https://oi-wiki.org/lang/op-overload/#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6">重载&nbsp;<code>()</code>&nbsp;运算符</a>。</p>
<p>例如，我们想要维护一个存储整数，且较大值靠前的&nbsp;<code>set</code>，可以这样实现：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> {</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> a &gt; b; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>, cmp&gt; s;</span><br></pre></td></tr></tbody></table></figure>
<p>对于其他关联式容器，可以用类似的方式实现自定义比较，这里不再赘述。</p>
<h2 id="无序关联式容器-1">无序关联式容器</h2>
<p>自 C++11 标准起，四种基于&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/ds/hash/">哈希<i class="fas fa-external-link-alt"></i></a>&nbsp;实现的无序关联式容器正式纳入了
C++
的标准模板库中，分别是：<code>unordered_set</code>，<code>unordered_multiset</code>，<code>unordered_map</code>，<code>unordered_multimap</code>。</p>
<p>它们与相应的关联式容器在功能，函数等方面有诸多共同点，而最大的不同点则体现在普通的关联式容器一般采用红黑树实现，内部元素按特定顺序进行排序；而这几种无序关联式容器则采用哈希方式存储元素，内部元素不以任何特定顺序进行排序，所以访问无序关联式容器中的元素时，访问顺序也没有任何保证。</p>
<p>采用哈希存储的特点使得无序关联式容器&nbsp;<strong>在平均情况下</strong>&nbsp;大多数操作（包括查找，插入，删除）都能在常数时间复杂度内完成，相较于关联式容器与容器大小成对数的时间复杂度更加优秀。</p>
<blockquote>
<p>在最坏情况下，对无序关联式容器进行插入、删除、查找等操作的时间复杂度会&nbsp;<strong>与容器大小成线性关系</strong>！这一情况往往在容器内出现大量哈希冲突时产生。</p>
<p>同时，由于无序关联式容器的操作时通常存在较大的常数，其效率有时并不比普通的关联式容器好太多。</p>
<p>因此应谨慎使用无序关联式容器，尽量避免滥用（例如懒得离散化，直接将&nbsp;<code>unordered_map&lt;int, int&gt;</code>&nbsp;当作空间无限的普通数组使用）。</p>
</blockquote>
<p>由于无序关联式容器与相应的关联式容器在用途和操作中有很多共同点，这里不再介绍无序关联式容器的各种操作，这些内容读者可以参考&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/lang/csl/associative-container/">关联式容器<i class="fas fa-external-link-alt"></i></a>。</p>
<h3 id="制造哈希冲突">制造哈希冲突</h3>
<p>上文中提到了，在最坏情况下，对无序关联式容器进行一些操作的时间复杂度会与容器大小成线性关系。</p>
<p>在哈希函数确定的情况下，可以构造出数据使得容器内产生大量哈希冲突，导致复杂度达到上界。</p>
<p>在标准库实现里，每个元素的散列值是将值对一个质数取模得到的，更具体地说，是&nbsp;<a class="link" target="_blank" rel="noopener" href="https://github.com/gcc-mirror/gcc/blob/releases/gcc-8.1.0/libstdc%2B%2B-v3/src/shared/hashtable-aux.cc">这个列表<i class="fas fa-external-link-alt"></i></a>&nbsp;中的质数（g++
6 及以前版本的编译器，这个质数一般是 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="6.787ex" height="1.579ex" role="img" focusable="false" viewBox="0 -676 3000 698"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(1000,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1500,0)"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(2000,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(2500,0)"></path></g></g></g></svg></mjx-container></span>，g++ 7
及之后版本的编译器，这个质数一般是<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="6.787ex" height="1.579ex" role="img" focusable="false" viewBox="0 -676 3000 698"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1000,0)"></path><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(1500,0)"></path><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z" transform="translate(2000,0)"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(2500,0)"></path></g></g></g></svg></mjx-container></span>。</p>
<p>因此可以通过向容器中插入这些模数的倍数来达到制造大量哈希冲突的目的。</p>
<h3 id="自定义哈希函数">自定义哈希函数</h3>
<p>使用自定义哈希函数可以有效避免构造数据产生的大量哈希冲突。要想使用自定义哈希函数，需要定义一个结构体，并在结构体中重载&nbsp;<code>()</code>&nbsp;运算符，像这样：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">my_hash</span> {</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>{<span class="keyword">return</span> x;}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当然，为了确保哈希函数不会被迅速破解（例如 Codeforces
中对使用无序关联式容器的提交进行
hack），可以试着在哈希函数中加入一些随机化函数（如时间）来增加破解的难度。</p>
<p>例如，在&nbsp;<a class="link" target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/62393">这篇博客<i class="fas fa-external-link-alt"></i></a>&nbsp;中给出了如下哈希函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">my_hash</span> { </span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title">splitmix64</span><span class="params">(<span class="type">uint64_t</span> x)</span> </span>{ </span><br><span class="line">		x += <span class="number">0x9e3779b97f4a7c15</span>; </span><br><span class="line">		x = (x ^ (x &gt;&gt; <span class="number">30</span>)) * <span class="number">0xbf58476d1ce4e5b9</span>;</span><br><span class="line">		x = (x ^ (x &gt;&gt; <span class="number">27</span>)) * <span class="number">0x94d049bb133111eb</span>; </span><br><span class="line">		<span class="keyword">return</span> x ^ (x &gt;&gt; <span class="number">31</span>); </span><br><span class="line">	} </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">uint64_t</span> x)</span> <span class="type">const</span> </span>{ </span><br><span class="line">		<span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> FIXED_RANDOM = </span><br><span class="line">				chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line">		 <span class="keyword">return</span> <span class="built_in">splitmix64</span>(x + FIXED_RANDOM); </span><br><span class="line">	} </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 针对 std::pair&lt;int, int&gt; 作为主键类型的哈希函数 </span></span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="type">uint64_t</span>, <span class="type">uint64_t</span>&gt; x)</span> <span class="type">const</span> </span>{ </span><br><span class="line">		<span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> FIXED_RANDOM = </span><br><span class="line">				chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>(); </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">splitmix64</span>(x.first + FIXED_RANDOM) ^ </span><br><span class="line">				(<span class="built_in">splitmix64</span>(x.second + FIXED_RANDOM) &gt;&gt; <span class="number">1</span>); </span><br><span class="line">	} </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>写完自定义的哈希函数后，就可以通过&nbsp;<code>unordered_map&lt;int, int, my_hash&gt; my_map;</code>&nbsp;或者&nbsp;<code>unordered_map&lt;pair&lt;int, int&gt;, int, my_hash&gt; my_pair_map;</code>&nbsp;的定义方式将自定义的哈希函数传入容器了。</p>
<h2 id="容器适配器-1">容器适配器</h2>
<h3 id="stack"><code>stack</code></h3>
<p>STL&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/ds/stack/">栈<i class="fas fa-external-link-alt"></i></a>(<code>std::stack</code>)
是一种后进先出 (Last In, First Out)
的容器适配器，仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问，且为了保证数据的严格有序性，不支持迭代器。</p>
<h4 id="定义">定义</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;TypeName&gt; s; <span class="comment">// 使用默认底层容器 deque，数据类型为 TypeName </span></span><br><span class="line">std::stack&lt;TypeName, Container&gt; s; <span class="comment">// 使用 Container 作为底层容器 </span></span><br><span class="line"><span class="function">std::stack&lt;TypeName&gt; <span class="title">s2</span><span class="params">(s1)</span></span>; <span class="comment">// 将 s1 复制一份用于构造 s2</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="成员函数">成员函数</h4>
<p><strong>以下所有函数均为常数复杂度</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>top()</code></td>
<td>访问栈顶元素（如果栈为空，此处会出错）</td>
</tr>
<tr>
<td><code>push(x)</code></td>
<td>向栈中插入元素 x</td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>删除栈顶元素</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>查询容器中的元素数量</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>询问容器是否为空</td>
</tr>
</tbody>
</table>
<h4 id="简单示例">简单示例</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>&gt; s1; </span><br><span class="line">s<span class="number">1.</span><span class="built_in">push</span>(<span class="number">2</span>); </span><br><span class="line">s<span class="number">1.</span><span class="built_in">push</span>(<span class="number">1</span>); </span><br><span class="line"><span class="function">std::stack&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(s1)</span></span>; </span><br><span class="line">s<span class="number">1.</span><span class="built_in">pop</span>(); </span><br><span class="line">std::cout &lt;&lt; s<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; s<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 1 2 </span></span><br><span class="line">std::cout &lt;&lt; s<span class="number">1.</span><span class="built_in">top</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; s<span class="number">2.</span><span class="built_in">top</span>() &lt;&lt; std::endl; <span class="comment">// 2 1 </span></span><br><span class="line">s<span class="number">1.</span><span class="built_in">pop</span>(); </span><br><span class="line">std::cout &lt;&lt; s<span class="number">1.</span><span class="built_in">empty</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; s<span class="number">2.</span><span class="built_in">empty</span>() &lt;&lt; std::endl; <span class="comment">// 1 0</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="queue"><code>queue</code></h3>
<p>STL&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/ds/queue/">队列<i class="fas fa-external-link-alt"></i></a>(<code>std::queue</code>)
是一种先进先出 (First In, First Out)
的容器适配器，仅支持查询或删除第一个加入的元素（队首元素），不支持随机访问，且为了保证数据的严格有序性，不支持迭代器。</p>
<h4 id="定义-1">定义</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;TypeName&gt; q; <span class="comment">// 使用默认底层容器 deque，数据类型为 TypeName </span></span><br><span class="line">std::queue&lt;TypeName, Container&gt; q; <span class="comment">// 使用 Container 作为底层容器 </span></span><br><span class="line"></span><br><span class="line"><span class="function">std::queue&lt;TypeName&gt; <span class="title">q2</span><span class="params">(q1)</span></span>; <span class="comment">// 将 s1 复制一份用于构造 q2</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="成员函数-1">成员函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>front()</code></td>
<td>访问队首元素（如果队列为空，此处会出错）</td>
</tr>
<tr>
<td><code>push(x)</code></td>
<td>向队列中插入元素 x</td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>删除队首元素</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>查询容器中的元素数量</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>询问容器是否为空</td>
</tr>
</tbody>
</table>
<h4 id="简单示例-1">简单示例</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>&gt; q1; </span><br><span class="line">q<span class="number">1.</span><span class="built_in">push</span>(<span class="number">2</span>); </span><br><span class="line">q<span class="number">1.</span><span class="built_in">push</span>(<span class="number">1</span>); </span><br><span class="line"><span class="function">std::queue&lt;<span class="type">int</span>&gt; <span class="title">q2</span><span class="params">(q1)</span></span>; </span><br><span class="line">q<span class="number">1.</span><span class="built_in">pop</span>(); std::cout &lt;&lt; q<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; q<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 1 2 </span></span><br><span class="line">std::cout &lt;&lt; q<span class="number">1.f</span>ront() &lt;&lt; <span class="string">" "</span> &lt;&lt; q<span class="number">2.f</span>ront() &lt;&lt; std::endl; <span class="comment">// 1 2 </span></span><br><span class="line">q<span class="number">1.</span><span class="built_in">pop</span>(); </span><br><span class="line">std::cout &lt;&lt; q<span class="number">1.</span><span class="built_in">empty</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; q<span class="number">2.</span><span class="built_in">empty</span>() &lt;&lt; std::endl; <span class="comment">// 1 0</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="priority_queue"><code>priority_queue</code></h3>
<p>优先队列&nbsp;<code>std::priority_queue</code>&nbsp;是一种&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/ds/heap/">堆<i class="fas fa-external-link-alt"></i></a>，一般为&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/ds/binary-heap/">二叉堆<i class="fas fa-external-link-alt"></i></a>。</p>
<h4 id="定义-2">定义</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">std::priority_queue&lt;TypeName&gt; q; <span class="comment">// 数据类型为 TypeName </span></span><br><span class="line">std::priority_queue&lt;TypeName, Container&gt; q; <span class="comment">// 使用 Container 作为底层容器 </span></span><br><span class="line">std::priority_queue&lt;TypeName, Container, Compare&gt; q; </span><br><span class="line"><span class="comment">// 使用 Container 作为底层容器，使用 Compare 作为比较类型 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认使用底层容器 vector </span></span><br><span class="line"><span class="comment">// 比较类型 less&lt;TypeName&gt;（此时为它的 top() 返回为最大值） </span></span><br><span class="line"><span class="comment">// 若希望 top() 返回最小值，可令比较类型为 greater&lt;TypeName&gt; </span></span><br><span class="line"><span class="comment">// 注意：不可跳过 Container 直接传入 Compare </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 C++11 开始，如果使用 lambda 函数自定义 Compare </span></span><br><span class="line"><span class="comment">// 则需要将其作为构造函数的参数代入，如： </span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;l, <span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;r) { </span><br><span class="line">	<span class="keyword">return</span> l.second &lt; r.second; </span><br><span class="line">}; </span><br><span class="line"></span><br><span class="line">std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; </span><br><span class="line"><span class="built_in">pq</span>(cmp);</span><br></pre></td></tr></tbody></table></figure>
<h4 id="成员函数-2">成员函数</h4>
<p><strong>以下所有函数均为常数复杂度</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>top()</code></td>
<td>访问堆顶元素（此时优先队列不能为空）</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>询问容器是否为空</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>查询容器中的元素数量</td>
</tr>
</tbody>
</table>
<p><strong>以下所有函数均为对数复杂度</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>push(x)</code></td>
<td>插入元素，并对底层容器排序</td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>删除堆顶元素（此时优先队列不能为空）</td>
</tr>
</tbody>
</table>
<h4 id="简单示例-2">简单示例</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::priority_queue&lt;<span class="type">int</span>&gt; q1; </span><br><span class="line">std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;&gt; q2; </span><br><span class="line"><span class="comment">// C++11 后空格可省略 </span></span><br><span class="line">std::priority_queue&lt;<span class="type">int</span>, std::deque&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; q3; </span><br><span class="line"><span class="comment">// q3 为小根堆 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) q<span class="number">1.</span><span class="built_in">push</span>(i); </span><br><span class="line"><span class="comment">// q1 中元素 : [1, 2, 3, 4, 5] </span></span><br><span class="line">std::cout &lt;&lt; q<span class="number">1.</span><span class="built_in">top</span>() &lt;&lt; std::endl; </span><br><span class="line"><span class="comment">// 输出结果 : 5 </span></span><br><span class="line">q<span class="number">1.</span><span class="built_in">pop</span>(); </span><br><span class="line"><span class="comment">// 堆中元素 : [1, 2, 3, 4] </span></span><br><span class="line">std::cout &lt;&lt; q<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; std::endl; </span><br><span class="line"><span class="comment">// 输出结果 ：4 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) q<span class="number">3.</span><span class="built_in">push</span>(i); </span><br><span class="line"><span class="comment">// q3 中元素 : [1, 2, 3, 4, 5] </span></span><br><span class="line">std::cout &lt;&lt; q<span class="number">3.</span><span class="built_in">top</span>() &lt;&lt; std::endl; </span><br><span class="line"><span class="comment">// 输出结果 : 1</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="stl算法">STL算法</h1>
<h2 id="排序相关stl">排序相关STL</h2>
<h3 id="qsort"><code>qsort</code></h3>
<p>该函数为 C 标准库实现的&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/basic/quick-sort/">快速排序<i class="fas fa-external-link-alt"></i></a>，定义在&nbsp;<code>&lt;stdlib.h&gt;</code>&nbsp;中。在
C++ 标准库里，该函数定义在&nbsp;<code>&lt;cstdlib&gt;</code>&nbsp;中。</p>
<h4 id="函数原型">函数原型</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">qsort</span>(<span class="type">void</span>* _Base, <span class="type">size_t</span> _NumOfElements, <span class="type">size_t</span> _SizeOfElements, <span class="built_in">int</span>(* _PtFuncCompare)(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*));</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>_Base</code>: 数组名</li>
<li><code>_NumOfElements</code>: 元素的个数</li>
<li><code>_SizeOfElements</code>: 元素的大小</li>
<li><code>_PtFuncCompare</code>: 比较函数</li>
</ul>
<p>qsort
函数有四个参数：数组名、元素个数、元素大小、比较规则。其中，比较规则通过指定比较函数来实现，指定不同的比较函数可以实现不同的排序规则。</p>
<p>比较函数的参数限定为两个 const void
类型的指针。返回值规定为正数、负数和 0。</p>
<p>比较函数的一种示例写法为：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p1, <span class="type">const</span> <span class="type">void</span>* p2)</span> </span>{</span><br><span class="line">	<span class="type">int</span>* a = (<span class="type">int</span>*)p1;</span><br><span class="line">	<span class="type">int</span>* b = (<span class="type">int</span>*)p2;</span><br><span class="line">	<span class="keyword">if</span> (*a &gt; *b) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (*a &lt; *b) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意：返回值用两个元素相减代替正负数是一种典型的错误写法，因为这样可能会导致溢出错误。</p>
<p>以下是排序结构体的一个示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">eg</span> {</span><br><span class="line">	<span class="type">int</span> e;</span><br><span class="line">	<span class="type">int</span> g;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p1, <span class="type">const</span> <span class="type">void</span>* p2)</span> </span>{</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">eg</span>* a = (<span class="keyword">struct</span> eg*)p1;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">eg</span>* b = (<span class="keyword">struct</span> eg*)p2;</span><br><span class="line">	<span class="keyword">if</span> (a-&gt;e &gt; b-&gt;e) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a-&gt;e &lt; b-&gt;e)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里也可以看出，等价不代表相等，只代表在此比较规则下两元素等价。</p>
<h3 id="stdsort"><code>std::sort</code></h3>
<h4 id="函数用法">函数用法</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a[0] ... a[n-1] 为需要排序的数列</span></span><br><span class="line"><span class="comment">// 对 a 原地排序，将其按从小到大的顺序排列</span></span><br><span class="line">std::<span class="built_in">sort</span>(a, a+n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cmp 为自定义的比较函数</span></span><br><span class="line">std::<span class="built_in">sort</span>(a, a+n, cmp);</span><br></pre></td></tr></tbody></table></figure>
<p>注意：sort 的比较函数的返回值是 true 和 false，用 true 和 false
表示两个元素的大小（先后）关系，这与 qsort
的三值比较函数的语义完全不同。具体内容详见上方给出的 sort 的文档。</p>
<p>如果要将 sort 简单改写为
qsort，维持排序顺序整体上不变（不考虑等价的元素），需要将返回 true 改为
- 1，返回 false 改为 1。</p>
<p><code>std::sort</code>&nbsp;函数是更常用的 C++
库比较函数。该函数的最后一个参数为二元比较函数，未指定&nbsp;<code>cmp</code>&nbsp;函数时，默认按从小到大的顺序排序。</p>
<p>旧版 C++ 标准中仅要求它的&nbsp;<strong>平均</strong>&nbsp;时间复杂度达到&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.847ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4352.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1918.7,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(3196.7,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(3363.3,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3963.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>。C++11
标准以及后续标准要求它的&nbsp;<strong>最坏</strong>&nbsp;时间复杂度达到&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.847ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4352.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1918.7,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(3196.7,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(3363.3,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3963.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>。</p>
<p>C++ 标准并未严格要求此函数的实现算法，具体实现取决于编译器。<a class="link" target="_blank" rel="noopener" href="https://github.com/mirrors/gcc/blob/master/libstdc++-v3/include/bits/stl_algo.h">libstdc++<i class="fas fa-external-link-alt"></i></a>&nbsp;和&nbsp;<a class="link" target="_blank" rel="noopener" href="http://llvm.org/svn/llvm-project/libcxx/trunk/include/algorithm">libc++<i class="fas fa-external-link-alt"></i></a>&nbsp;中的实现都使用了&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/basic/quick-sort/#%E5%86%85%E7%9C%81%E6%8E%92%E5%BA%8F">内省排序<i class="fas fa-external-link-alt"></i></a>。</p>
<h3 id="stdnth_element"><code>std::nth_element</code></h3>
<h4 id="函数用法-1">函数用法</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">nth_element</span>(first, nth, last);</span><br><span class="line">std::<span class="built_in">nth_element</span>(first, nth, last, cmp);</span><br></pre></td></tr></tbody></table></figure>
<p>它重排&nbsp;<code>[first, last)</code>&nbsp;中的元素，使得&nbsp;<code>nth</code>&nbsp;所指向的元素被更改为&nbsp;<code>[first, last)</code>&nbsp;排好序后该位置会出现的元素。这个新的&nbsp;<code>nth</code>&nbsp;元素前的所有元素小于或等于新的&nbsp;<code>nth</code>&nbsp;元素后的所有元素。</p>
<p>实现算法是未完成的内省排序。</p>
<p>对于以上两种用法，C++ 标准要求它的平均时间复杂度为&nbsp;<img lazyload="" alt="image" data-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="O(n)">，其中 n 为&nbsp;<code>std::distance(first, last)</code>。</p>
<p>它常用于构建&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/ds/kdt/">K-D Tree<i class="fas fa-external-link-alt"></i></a>。</p>
<h3 id="stdstable_sort"><code>std::stable_sort</code></h3>
<h4 id="函数用法-2">函数用法</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">stable_sort</span>(first, last);</span><br><span class="line">std::<span class="built_in">stable_sort</span>(first, last, cmp);</span><br></pre></td></tr></tbody></table></figure>
<p>稳定排序，保证相等元素排序后的相对位置与原序列相同。</p>
<p>时间复杂度为&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.835ex" height="2.584ex" role="img" focusable="false" viewBox="0 -892 4788.9 1142"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="msup" transform="translate(1918.7,0)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mn" transform="translate(1311,421.1) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(3633.2,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(3799.9,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(4399.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>，当额外内存可用时，复杂度为&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.847ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4352.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1918.7,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(3196.7,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(3363.3,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3963.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>。</p>
<h3 id="stdpartial_sort"><code>std::partial_sort</code></h3>
<h4 id="函数用法-3">函数用法</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mid = first + k </span></span><br><span class="line">std::<span class="built_in">partial_sort</span>(first, mid, last); </span><br><span class="line">std::<span class="built_in">partial_sort</span>(first, mid, last, cmp);</span><br></pre></td></tr></tbody></table></figure>
<p>将序列中前&nbsp;<code>k</code>&nbsp;元素按&nbsp;<code>cmp</code>&nbsp;给定的顺序进行原地排序，后面的元素不保证顺序。未指定&nbsp;<code>cmp</code>&nbsp;函数时，默认按从小到大的顺序排序。</p>
<p>复杂度：约&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="27.474ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 12143.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="6C" d="M162 61Q162 26 183 26Q211 26 239 131Q245 151 249 152Q252 153 261 153H266H271Q288 153 288 144Q288 143 286 129Q276 91 266 65T232 14T179 -11Q144 -11 116 12T87 81Q87 96 88 102L216 616Q216 629 209 632T170 637H149Q143 643 143 645T145 664Q150 683 158 683Q163 683 223 688T300 694Q312 694 312 686Q312 676 240 389L164 86Q162 74 162 61Z"></path><path data-c="61" d="M418 53Q418 26 438 26Q466 26 494 131Q500 151 504 152Q507 153 516 153H521Q531 153 534 153T540 150T543 144Q543 141 540 126T529 88T509 43T477 5T434 -11Q404 -11 383 3T354 30T347 48H346Q345 47 342 45T337 40Q282 -11 228 -11Q172 -11 137 34T101 146Q101 260 177 351T333 442Q343 442 352 441T369 437T382 431T393 425T402 417T409 410T414 402T419 396Q423 406 436 414T461 422Q475 422 484 413T494 395Q494 384 459 244T420 88Q418 80 418 58V53ZM397 323Q397 344 382 374T333 405Q302 405 271 372Q249 349 235 316T203 215Q184 135 184 108V100V94Q184 54 207 35Q218 26 235 26Q279 26 330 91Q343 109 346 118T372 217Q397 317 397 323Z" transform="translate(256,0)"></path><path data-c="73" d="M153 285Q153 349 197 395T311 442Q355 442 386 420T418 356Q418 321 401 308T365 294Q336 294 331 326Q331 336 334 345T343 359T353 368T362 374L366 376Q365 379 362 383T344 396T308 404Q265 404 246 377T226 325T244 289T287 275T339 258T383 212Q395 188 395 163Q395 132 379 95T333 32Q279 -11 207 -11Q154 -11 115 13T76 86Q76 108 83 123T102 145T121 153T135 156Q154 156 164 145T175 117Q175 82 142 66L132 62Q131 62 131 61Q131 57 139 49T166 34T210 26Q250 26 277 44T312 83T321 123Q321 153 301 166T248 185T204 198Q176 211 162 241Q153 258 153 285Z" transform="translate(767,0)"></path><path data-c="74" d="M94 385Q87 392 87 395Q87 399 90 411T95 425Q97 430 103 430T149 431H196L215 511Q218 521 222 539T228 565T234 585T242 603T251 615T264 623T281 626Q311 626 315 597Q315 591 296 513T275 433Q275 431 320 431H366Q373 424 373 420Q373 398 360 385H263L189 86Q188 80 188 61V54Q188 29 201 27Q213 23 229 30Q253 37 276 66T316 138Q321 149 324 151T342 153H347Q364 153 364 146T360 130Q331 63 290 26T202 -11Q158 -11 135 18T111 81Q111 93 129 168T166 314L184 383Q184 385 139 385H94Z" transform="translate(1176,0)"></path></g></g><g data-mml-node="mo" transform="translate(2119.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3119.4,0)"><g data-mml-node="mi"><path data-c="66" d="M351 608Q351 642 389 661Q368 668 365 668Q358 668 352 664Q349 663 347 661T342 654T337 647T333 637T330 627T327 614T324 601T321 587T318 571L291 432Q291 431 343 431H394Q400 426 400 423T398 404Q394 390 389 386L335 385H282L255 246Q212 20 189 -51Q136 -199 58 -204Q22 -204 0 -185T-23 -134Q-23 -100 -3 -85T37 -69Q54 -69 65 -80T76 -108Q76 -115 75 -119Q70 -134 61 -144T46 -158L39 -161Q39 -162 42 -163T50 -166T61 -168Q77 -168 91 -145Q98 -128 105 -95L125 -1Q145 90 146 98Q149 109 163 180T189 317T202 384T158 385H114Q108 390 108 393T110 412Q113 424 120 431H165Q211 431 211 433Q213 435 219 473T237 561T266 639Q282 667 310 686T367 705Q402 705 426 686T450 635Q450 600 430 585T390 569Q373 569 362 580T351 608Z"></path><path data-c="69" d="M234 599Q234 620 251 638T292 656Q306 656 319 647T332 617Q332 594 313 577T273 560Q260 560 247 569T234 599ZM75 287Q75 292 82 313T103 362T142 413T196 441H214Q248 441 270 419T293 357Q292 338 289 330T245 208Q193 72 193 46Q193 26 209 26Q228 26 247 43Q273 71 292 136Q295 148 297 150T311 153H317Q327 153 330 153T337 150T340 143Q340 133 330 105T292 41T228 -8Q220 -10 204 -10Q160 -10 141 15T122 71Q122 98 171 227T221 384Q221 396 218 400T203 405Q175 403 156 374T128 312T116 279Q115 278 97 278H81Q75 284 75 287Z" transform="translate(307,0)"></path><path data-c="72" d="M81 278Q75 284 75 289Q77 301 89 339Q122 442 183 442Q219 442 241 425T271 384L283 396Q327 442 384 442Q424 442 454 421T484 362Q484 327 464 312T424 296Q407 296 396 305T385 331Q385 352 394 365T414 384T424 390Q409 405 378 405Q322 405 276 315L268 300L234 161Q200 25 196 16Q182 -11 152 -11T120 18Q120 23 159 181Q199 343 199 346Q202 360 202 372Q202 405 182 405Q164 405 150 377T128 316T117 280Q115 278 98 278H81Z" transform="translate(614,0)"></path><path data-c="73" d="M153 285Q153 349 197 395T311 442Q355 442 386 420T418 356Q418 321 401 308T365 294Q336 294 331 326Q331 336 334 345T343 359T353 368T362 374L366 376Q365 379 362 383T344 396T308 404Q265 404 246 377T226 325T244 289T287 275T339 258T383 212Q395 188 395 163Q395 132 379 95T333 32Q279 -11 207 -11Q154 -11 115 13T76 86Q76 108 83 123T102 145T121 153T135 156Q154 156 164 145T175 117Q175 82 142 66L132 62Q131 62 131 61Q131 57 139 49T166 34T210 26Q250 26 277 44T312 83T321 123Q321 153 301 166T248 185T204 198Q176 211 162 241Q153 258 153 285Z" transform="translate(1036,0)"></path><path data-c="74" d="M94 385Q87 392 87 395Q87 399 90 411T95 425Q97 430 103 430T149 431H196L215 511Q218 521 222 539T228 565T234 585T242 603T251 615T264 623T281 626Q311 626 315 597Q315 591 296 513T275 433Q275 431 320 431H366Q373 424 373 420Q373 398 360 385H263L189 86Q188 80 188 61V54Q188 29 201 27Q213 23 229 30Q253 37 276 66T316 138Q321 149 324 151T342 153H347Q364 153 364 146T360 130Q331 63 290 26T202 -11Q158 -11 135 18T111 81Q111 93 129 168T166 314L184 383Q184 385 139 385H94Z" transform="translate(1445,0)"></path></g></g><g data-mml-node="mo" transform="translate(4896.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mi" transform="translate(5452.1,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(6730.1,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mo" transform="translate(6730.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(7119.1,0)"><g data-mml-node="mi"><path data-c="6D" d="M81 278Q75 284 75 289Q77 299 89 338Q101 373 114 396T142 428T166 439T186 442H189Q225 440 251 417Q266 401 271 384L275 374L286 386Q342 442 414 442Q428 442 440 440T461 435T479 427T493 418T503 407T511 397T516 387T520 378T523 370L524 366Q546 395 583 418T667 442Q729 442 755 411T782 338Q782 290 743 178T704 45Q704 26 720 26Q773 26 802 136Q805 148 807 150T822 153H828Q838 153 841 153T848 150T851 143Q851 137 843 115T821 63T778 12T715 -10Q671 -10 652 16T632 71Q632 88 668 191T704 349Q704 367 703 372Q693 405 664 405Q637 405 613 393T571 360T547 329T534 309Q523 290 518 274T487 151Q455 24 452 16Q438 -11 408 -11T376 18Q376 26 411 167T447 314Q449 325 449 346Q449 372 444 384Q431 405 408 405Q334 405 276 305Q266 289 262 273T231 151Q199 24 196 16Q182 -11 152 -11T120 18Q120 26 159 182T200 347Q202 361 202 372Q202 405 181 405Q168 405 159 391Q145 374 132 328T117 280T98 278H81Z"></path><path data-c="69" d="M234 599Q234 620 251 638T292 656Q306 656 319 647T332 617Q332 594 313 577T273 560Q260 560 247 569T234 599ZM75 287Q75 292 82 313T103 362T142 413T196 441H214Q248 441 270 419T293 357Q292 338 289 330T245 208Q193 72 193 46Q193 26 209 26Q228 26 247 43Q273 71 292 136Q295 148 297 150T311 153H317Q327 153 330 153T337 150T340 143Q340 133 330 105T292 41T228 -8Q220 -10 204 -10Q160 -10 141 15T122 71Q122 98 171 227T221 384Q221 396 218 400T203 405Q175 403 156 374T128 312T116 279Q115 278 97 278H81Q75 284 75 287Z" transform="translate(818,0)"></path><path data-c="64" d="M418 54Q418 26 438 26Q466 26 494 131Q500 151 504 152Q507 153 516 153H521H526Q543 153 543 144Q543 143 541 129Q531 91 521 65T487 14T434 -11T383 3T354 30T347 48H346Q345 47 342 45T337 40Q282 -11 228 -11Q172 -11 137 34T101 146Q101 255 174 348T337 441Q354 441 368 437T390 427T404 414T413 404T417 400L471 616Q471 629 464 632T425 637H404Q398 643 398 645T400 664Q405 683 413 683Q418 683 478 688T555 694Q567 694 567 686Q567 676 495 389L419 86Q418 80 418 61V54ZM397 323Q397 329 394 340T385 367T365 394T333 405Q302 405 271 372Q249 349 235 316T203 215Q184 135 184 108V100Q184 71 191 56Q204 26 235 26Q267 26 300 57T344 112Q347 117 372 217T397 323Z" transform="translate(1125,0)"></path></g></g><g data-mml-node="mo" transform="translate(8977.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(9977.6,0)"><g data-mml-node="mi"><path data-c="66" d="M351 608Q351 642 389 661Q368 668 365 668Q358 668 352 664Q349 663 347 661T342 654T337 647T333 637T330 627T327 614T324 601T321 587T318 571L291 432Q291 431 343 431H394Q400 426 400 423T398 404Q394 390 389 386L335 385H282L255 246Q212 20 189 -51Q136 -199 58 -204Q22 -204 0 -185T-23 -134Q-23 -100 -3 -85T37 -69Q54 -69 65 -80T76 -108Q76 -115 75 -119Q70 -134 61 -144T46 -158L39 -161Q39 -162 42 -163T50 -166T61 -168Q77 -168 91 -145Q98 -128 105 -95L125 -1Q145 90 146 98Q149 109 163 180T189 317T202 384T158 385H114Q108 390 108 393T110 412Q113 424 120 431H165Q211 431 211 433Q213 435 219 473T237 561T266 639Q282 667 310 686T367 705Q402 705 426 686T450 635Q450 600 430 585T390 569Q373 569 362 580T351 608Z"></path><path data-c="69" d="M234 599Q234 620 251 638T292 656Q306 656 319 647T332 617Q332 594 313 577T273 560Q260 560 247 569T234 599ZM75 287Q75 292 82 313T103 362T142 413T196 441H214Q248 441 270 419T293 357Q292 338 289 330T245 208Q193 72 193 46Q193 26 209 26Q228 26 247 43Q273 71 292 136Q295 148 297 150T311 153H317Q327 153 330 153T337 150T340 143Q340 133 330 105T292 41T228 -8Q220 -10 204 -10Q160 -10 141 15T122 71Q122 98 171 227T221 384Q221 396 218 400T203 405Q175 403 156 374T128 312T116 279Q115 278 97 278H81Q75 284 75 287Z" transform="translate(307,0)"></path><path data-c="72" d="M81 278Q75 284 75 289Q77 301 89 339Q122 442 183 442Q219 442 241 425T271 384L283 396Q327 442 384 442Q424 442 454 421T484 362Q484 327 464 312T424 296Q407 296 396 305T385 331Q385 352 394 365T414 384T424 390Q409 405 378 405Q322 405 276 315L268 300L234 161Q200 25 196 16Q182 -11 152 -11T120 18Q120 23 159 181Q199 343 199 346Q202 360 202 372Q202 405 182 405Q164 405 150 377T128 316T117 280Q115 278 98 278H81Z" transform="translate(614,0)"></path><path data-c="73" d="M153 285Q153 349 197 395T311 442Q355 442 386 420T418 356Q418 321 401 308T365 294Q336 294 331 326Q331 336 334 345T343 359T353 368T362 374L366 376Q365 379 362 383T344 396T308 404Q265 404 246 377T226 325T244 289T287 275T339 258T383 212Q395 188 395 163Q395 132 379 95T333 32Q279 -11 207 -11Q154 -11 115 13T76 86Q76 108 83 123T102 145T121 153T135 156Q154 156 164 145T175 117Q175 82 142 66L132 62Q131 62 131 61Q131 57 139 49T166 34T210 26Q250 26 277 44T312 83T321 123Q321 153 301 166T248 185T204 198Q176 211 162 241Q153 258 153 285Z" transform="translate(1036,0)"></path><path data-c="74" d="M94 385Q87 392 87 395Q87 399 90 411T95 425Q97 430 103 430T149 431H196L215 511Q218 521 222 539T228 565T234 585T242 603T251 615T264 623T281 626Q311 626 315 597Q315 591 296 513T275 433Q275 431 320 431H366Q373 424 373 420Q373 398 360 385H263L189 86Q188 80 188 61V54Q188 29 201 27Q213 23 229 30Q253 37 276 66T316 138Q321 149 324 151T342 153H347Q364 153 364 146T360 130Q331 63 290 26T202 -11Q158 -11 135 18T111 81Q111 93 129 168T166 314L184 383Q184 385 139 385H94Z" transform="translate(1445,0)"></path></g></g><g data-mml-node="mo" transform="translate(11754.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>&nbsp;次应用&nbsp;<code>cmp</code>。</p>
<p>原理：</p>
<p><code>std::partial_sort</code>&nbsp;的思想是：对原始容器内区间为&nbsp;<code>[first, mid)</code>&nbsp;的元素执行&nbsp;<code>make_heap()</code>&nbsp;操作，构造一个大根堆，然后将&nbsp;<code>[mid, last)</code>&nbsp;中的每个元素和&nbsp;<code>first</code>&nbsp;进行比较，保证&nbsp;<code>first</code>&nbsp;内的元素为堆内的最大值。如果小于该最大值，则互换元素位置，并对&nbsp;<code>[first, mid)</code>&nbsp;内的元素进行调整，使其保持最大堆序。比较完之后，再对&nbsp;<code>[first, mid)</code>&nbsp;内的元素做一次堆排序&nbsp;<code>sort_heap()</code>&nbsp;操作，使其按增序排列。注意，堆序和增序是不同的。</p>
<h3 id="自定义比较">自定义比较</h3>
<p>参见：<a class="link" target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/operators">运算符重载<i class="fas fa-external-link-alt"></i></a></p>
<p>内置类型（如&nbsp;<code>int</code>）和用户定义的结构体允许定制调用 STL
排序函数时使用的比较函数。可以在调用该函数时，在最后一个参数中传入一个实现二元比较的函数。</p>
<p>对于用户定义的结构体，对其使用 STL
排序函数前必须定义至少一种关系运算符，或是在使用函数时提供二元比较函数。通常推荐定义&nbsp;<code>operator&lt;</code>。</p>
<p>示例</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">1009</span>], n=<span class="number">10</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n); <span class="comment">// 从小到大排序</span></span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>，a + <span class="number">1</span> + n, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 从大到小排序</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span> {</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> data rhs) {</span><br><span class="line">		<span class="keyword">return</span> (a == rhs.a) ? (b &lt; rhs.b) : (a &lt; rhs.a);</span><br><span class="line">	}</span><br><span class="line">} da[<span class="number">1009</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> data u1, <span class="type">const</span> data u2)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> (u<span class="number">1.</span>a == u<span class="number">2.</span>a) ? (u<span class="number">1.</span>b &gt; u<span class="number">2.</span>b) : (u<span class="number">1.</span>a &gt; u<span class="number">2.</span>a);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">std::<span class="built_in">sort</span>(da + <span class="number">1</span>, da + <span class="number">1</span> + <span class="number">10</span>)； <span class="comment">// 使用结构体中定义的 &lt; 运算符，从小到大排序</span></span><br><span class="line">std::<span class="built_in">sort</span>(da + <span class="number">1</span>, da + <span class="number">1</span> + <span class="number">10</span>, cmp);  <span class="comment">// 使用 cmp 函数进行比较，从大到小排序</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="其他stl算法">其他STL算法</h2>
<table>
<colgroup>
<col style="width: 11%">
<col style="width: 88%">
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>find</code></td>
<td>顺序查找。<code>find(v.begin(), v.end(), value)</code>，其中&nbsp;<code>value</code>&nbsp;为需要查找的值。</td>
</tr>
<tr>
<td><code>reverse</code></td>
<td>翻转数组、字符串。<code>reverse(v.begin(), v.end())</code>&nbsp;或&nbsp;<code>reverse(a + begin, a + end)</code>。</td>
</tr>
<tr>
<td><code>unique</code></td>
<td>去除容器中相邻的重复元素。<code>unique(ForwardIterator first, ForwardIterator last)</code>，返回值为指向&nbsp;<strong>去重后</strong>&nbsp;容器结尾的迭代器，原容器大小不变。与&nbsp;<code>sort</code>&nbsp;结合使用可以实现完整容器去重。</td>
</tr>
<tr>
<td><code>random_shuffle</code></td>
<td>随机地打乱数组。<code>random_shuffle(v.begin(), v.end())</code>&nbsp;或&nbsp;<code>random_shuffle(v + begin, v + end)</code>。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>random_shuffle</code>&nbsp;自 C++14 起被弃用，C++17 起被移除。</p>
<p>在 C++11
以及更新的标准中，您可以使用&nbsp;<code>shuffle</code>&nbsp;函数代替原来的&nbsp;<code>random_shuffle</code>。使用方法为&nbsp;<code>shuffle(v.begin(), v.end(), rng)</code>（最后一个参数传入的是使用的随机数生成器，一般情况使用以真随机数生成器&nbsp;<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/random/random_device"><code>random_device</code></a>&nbsp;播种的梅森旋转伪随机数生成器&nbsp;<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine"><code>mt19937</code></a>）。</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;random&gt; </span></span><br><span class="line"><span class="function">std::mt19937 <span class="title">rng</span><span class="params">(std::random_device{}())</span></span>; </span><br><span class="line">std::<span class="built_in">shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), rng);</span><br></pre></td></tr></tbody></table></figure>
<table>
<colgroup>
<col style="width: 5%">
<col style="width: 94%">
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sort</code></td>
<td>排序。<code>sort(v.begin(), v.end(), cmp)</code>&nbsp;或&nbsp;<code>sort(a + begin, a + end, cmp)</code>，其中&nbsp;<code>end</code>&nbsp;是排序的数组最后一个元素的后一位，<code>cmp</code>&nbsp;为自定义的比较函数。</td>
</tr>
<tr>
<td><code>stable_sort</code></td>
<td>稳定排序，用法同&nbsp;<code>sort()</code>。</td>
</tr>
<tr>
<td><code>nth_element</code></td>
<td>按指定范围进行分类，即找出序列中第&nbsp;<img lazyload="" alt="image" data-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="n">&nbsp;大的元素，使其左边均为小于它的数，右边均为大于它的数。<code>nth_element(v.begin(), v.begin() + mid, v.end(), cmp)</code>&nbsp;或&nbsp;<code>nth_element(a + begin, a + begin + mid, a + end, cmp)</code>。</td>
</tr>
<tr>
<td><code>binary_search</code></td>
<td>二分查找。<code>binary_search(v.begin(), v.end(), value)</code>，其中&nbsp;<code>value</code>&nbsp;为需要查找的值。</td>
</tr>
<tr>
<td><code>merge</code></td>
<td>将两个（已排序的）序列&nbsp;<strong>有序合并</strong>&nbsp;到第三个序列的&nbsp;<strong>插入迭代器</strong>&nbsp;上。<code>merge(v1.begin(), v1.end(), v2.begin(), v2.end() ,back_inserter(v3))</code>。</td>
</tr>
<tr>
<td><code>lower_bound</code></td>
<td>在一个有序序列中进行二分查找，返回指向第一个&nbsp;<strong>大于等于</strong>&nbsp;<img lazyload="" alt="image" data-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="x">&nbsp;的元素的位置的迭代器。如果不存在这样的元素，则返回尾迭代器。<code>lower_bound(v.begin(),v.end(),x)</code>。</td>
</tr>
<tr>
<td><code>upper_bound</code></td>
<td>在一个有序序列中进行二分查找，返回指向第一个&nbsp;<strong>大于</strong>&nbsp;<img lazyload="" alt="image" data-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="x">&nbsp;的元素的位置的迭代器。如果不存在这样的元素，则返回尾迭代器。<code>upper_bound(v.begin(),v.end(),x)</code>。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>lower_bound</code>&nbsp;和&nbsp;<code>upper_bound</code>&nbsp;的时间复杂度</p>
<p>在一般的数组里，这两个函数的时间复杂度均为&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.112ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3585.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(2430,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(2596.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3196.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>，但在&nbsp;<code>set</code>&nbsp;等关联式容器中，直接调用&nbsp;<code>lower_bound(s.begin(),s.end(),val)</code>&nbsp;的时间复杂度是&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>&nbsp;的。</p>
<p><code>set</code>&nbsp;等关联式容器中已经封装了&nbsp;<code>lower_bound</code>&nbsp;等函数（像&nbsp;<code>s.lower_bound(val)</code>&nbsp;这样），这样调用的时间复杂度是&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.112ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3585.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(2430,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(2596.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3196.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>&nbsp;的。</p>
</blockquote>
<table>
<colgroup>
<col style="width: 8%">
<col style="width: 91%">
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>next_permutation</code></td>
<td>将当前排列更改为&nbsp;<strong>全排列中的下一个排列</strong>。如果当前排列已经是&nbsp;<strong>全排列中的最后一个排列</strong>（元素完全从大到小排列），函数返回&nbsp;<code>false</code>&nbsp;并将排列更改为&nbsp;<strong>全排列中的第一个排列</strong>（元素完全从小到大排列）；否则，函数返回&nbsp;<code>true</code>。<code>next_permutation(v.begin(), v.end())</code>&nbsp;或&nbsp;<code>next_permutation(v + begin, v + end)</code>。</td>
</tr>
<tr>
<td><code>prev_permutation</code></td>
<td>将当前排列更改为&nbsp;<strong>全排列中的上一个排列</strong>。用法同&nbsp;<code>next_permutation</code>。</td>
</tr>
<tr>
<td><code>partial_sum</code></td>
<td>求前缀和。设源容器为&nbsp;<img lazyload="" alt="image" data-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="x">，目标容器为 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewBox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span>，则令<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="27.812ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 12292.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(490,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(768,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1113,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(1668.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2724.6,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(3296.6,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(3574.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(4074.6,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(4574.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(5575,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(6147,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(6425,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(6925,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(7425.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(8425.4,0)"><path data-c="22EF" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250ZM525 250Q525 274 542 292T585 310Q609 310 627 294T646 251Q646 226 629 208T586 190T543 207T525 250ZM972 250Q972 274 989 292T1032 310Q1056 310 1074 294T1093 251Q1093 226 1076 208T1033 190T990 207T972 250Z"></path></g><g data-mml-node="mo" transform="translate(9819.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(10819.9,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(11391.9,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(11669.9,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(12014.9,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container></span>。<code>partial_sum(src.begin(), src.end(), back_inserter(dst))</code>。</td>
</tr>
</tbody>
</table>
<h3 id="示例">示例</h3>
<p>使用&nbsp;<code>next_permutation</code>&nbsp;生成&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>&nbsp;到&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z"></path></g></g></g></svg></mjx-container></span>&nbsp;的全排列。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> N = <span class="number">9</span>, a[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>};</span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">} <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a, a + N));</span><br></pre></td></tr></tbody></table></figure>
<p>使用&nbsp;<code>lower_bound</code>&nbsp;与&nbsp;<code>upper_bound</code>&nbsp;查找有序数组&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.02ex" role="img" focusable="false" viewBox="0 -441 529 451"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></svg></mjx-container></span>&nbsp;中小于 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></mjx-container></span>，等于&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></mjx-container></span>，大于&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></mjx-container></span>)&nbsp;元素的分界线。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> N = <span class="number">10</span>, a[] = {<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">9</span>}, x = <span class="number">5</span>; </span><br><span class="line"><span class="type">int</span> i = <span class="built_in">lower_bound</span>(a, a + N, x) - a, j = <span class="built_in">upper_bound</span>(a, a + N, x) - a; </span><br><span class="line"><span class="comment">// a[0] ~ a[i - 1] 为小于x的元素， a[i] ~ a[j - 1] 为等于x的元素， </span></span><br><span class="line"><span class="comment">// a[j] ~ a[N - 1] 为大于x的元素 </span></span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure>
<p>使用&nbsp;<code>partial_sum</code>&nbsp;求解&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="3.061ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 1353 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(469,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(920,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g></g></g></svg></mjx-container></span>&nbsp;中元素的前缀和，并存储于&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="3.054ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 1350 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g></g></svg></mjx-container></span>&nbsp;中。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; src = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}, dst; </span><br><span class="line"><span class="comment">// 求解src中元素的前缀和，dst[i] = src[0] + ... + src[i] </span></span><br><span class="line"><span class="comment">// back_inserter 函数作用在 dst 容器上，提供一个迭代器 </span></span><br><span class="line"><span class="built_in">partial_sum</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), <span class="built_in">back_inserter</span>(dst)); </span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; dst.<span class="built_in">size</span>(); i++) cout &lt;&lt; dst[i] &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>使用&nbsp;<code>lower_bound</code>&nbsp;查找有序数组&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.02ex" role="img" focusable="false" viewBox="0 -441 529 451"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></svg></mjx-container></span>&nbsp;中最接近&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></mjx-container></span>&nbsp;的元素。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> N = <span class="number">10</span>, a[] = {<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>}, x = <span class="number">6</span>; </span><br><span class="line"><span class="comment">// lower_bound将返回a中第一个大于等于x的元素的地址，计算出的i为其下标 </span></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">lower_bound</span>(a, a + N, x) - a; </span><br><span class="line"><span class="comment">// 在以下两种情况下，a[i] (a中第一个大于等于x的元素) 即为答案： </span></span><br><span class="line"><span class="comment">// 1. a中最小的元素都大于等于x； </span></span><br><span class="line"><span class="comment">// 2. a中存在大于等于x的元素，且第一个大于等于x的元素 (a[i]) </span></span><br><span class="line"><span class="comment">// 相比于第一个小于x的元素 (a[i - 1]) 更接近x； </span></span><br><span class="line"><span class="comment">// 否则，a[i - 1] (a中第一个小于x的元素) 即为答案 </span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> || (i &lt; N &amp;&amp; a[i] - x &lt; x - a[i - <span class="number">1</span>])) </span><br><span class="line">	cout &lt;&lt; a[i]; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	cout &lt;&lt; a[i - <span class="number">1</span>];</span><br></pre></td></tr></tbody></table></figure>
<p>使用&nbsp;<code>sort</code>&nbsp;与&nbsp;<code>unique</code>&nbsp;查找数组&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.02ex" role="img" focusable="false" viewBox="0 -441 529 451"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></svg></mjx-container></span>&nbsp;中&nbsp;<strong>第 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></svg></mjx-container></span>&nbsp;小的值</strong>（注意：重复出现的值仅算一次，因此本题不是求解第&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></svg></mjx-container></span>&nbsp;小的元素）。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> N = <span class="number">10</span>, a[] = {<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>}, k=<span class="number">3</span>;</span><br><span class="line"><span class="built_in">sort</span>(a, a + N);</span><br><span class="line"><span class="comment">// unique 将返回去重之后数组最后一个元素之后的地址，计算出的cnt为去重后数组的长度</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="built_in">unique</span>(a, a + N) - a;</span><br><span class="line">cout &lt;&lt; a[k<span class="number">-1</span>];</span><br></pre></td></tr></tbody></table></figure>
<h1 id="字符串标准库">字符串标准库</h1>
<h2 id="c-标准库">C 标准库</h2>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 70%">
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>printf("%s", s)</code></td>
<td>用&nbsp;<code>%s</code>&nbsp;来输出一个字符串（字符数组）</td>
</tr>
<tr>
<td><code>scanf("%s", &amp;s)</code></td>
<td>用&nbsp;<code>%s</code>&nbsp;来读入一个字符串（字符数组）</td>
</tr>
<tr>
<td><code>sscanf(const char *__source, const char *__format, ...)</code></td>
<td>从字符串&nbsp;<code>__source</code>&nbsp;里读取变量，比如&nbsp;<code>sscanf(str,"%d",&amp;a)</code>。</td>
</tr>
<tr>
<td><code>sprintf(char *__stream, const char *__format, ...)</code></td>
<td>将&nbsp;<code>__format</code>&nbsp;字符串里的内容输出到&nbsp;<code>__stream</code>&nbsp;中，比如&nbsp;<code>sprintf(str,"%d",i)</code>。</td>
</tr>
<tr>
<td><code>strlen(const char *str)</code></td>
<td>返回从&nbsp;<code>str[0]</code>&nbsp;开始直到&nbsp;<code>'\0'</code>&nbsp;的字符数。注意，未开启
O2 优化时，该操作写在循环条件中复杂度是&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.529ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2444 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="398" d="M56 340Q56 423 86 494T164 610T270 680T388 705Q521 705 621 601T722 341Q722 260 693 191T617 75T510 4T388 -22T267 3T160 74T85 189T56 340ZM610 339Q610 428 590 495T535 598T463 651T384 668Q332 668 289 638T221 566Q168 485 168 339Q168 274 176 235Q189 158 228 105T324 28Q356 16 388 16Q415 16 442 24T501 54T555 111T594 205T610 339ZM223 263V422H263V388H514V422H554V263H514V297H263V263H223Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1167,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(2055,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>&nbsp;的。</td>
</tr>
<tr>
<td><code>strcmp(const char *str1, const char *str2)</code></td>
<td>按照字典序比较&nbsp;<code>str1 str2</code>&nbsp;若&nbsp;<code>str1</code>&nbsp;字典序小返回负值，两者一样返回&nbsp;<code>0</code>，<code>str1</code>&nbsp;字典序更大则返回正值。请注意，不要简单的认为返回值只有&nbsp;<code>0</code>、<code>1</code>、<code>-1</code>&nbsp;三种，在不同平台下的返回值都遵循正负，但并非都是&nbsp;<code>0</code>、<code>1</code>、<code>-1</code>。<br></td>
</tr>
<tr>
<td><code>strcpy(char *str, const char *src)</code></td>
<td>把&nbsp;<code>src</code>&nbsp;中的字符复制到&nbsp;<code>str</code>&nbsp;中，<code>str</code>&nbsp;<code>src</code>&nbsp;均为字符数组头指针，返回值为&nbsp;<code>str</code>&nbsp;包含空终止符号&nbsp;<code>'\0'</code>。</td>
</tr>
<tr>
<td><code>strncpy(char *str, const char *src, int cnt)</code></td>
<td>复制至多&nbsp;<code>cnt</code>&nbsp;个字符到&nbsp;<code>str</code>&nbsp;中，若&nbsp;<code>src</code>&nbsp;终止而数量未达&nbsp;<code>cnt</code>&nbsp;则写入空字符到&nbsp;<code>str</code>&nbsp;直至写入总共&nbsp;<code>cnt</code>&nbsp;个字符。</td>
</tr>
<tr>
<td><code>strcat(char *str1, const char *str2)</code></td>
<td>将&nbsp;<code>str2</code>&nbsp;接到&nbsp;<code>str1</code>&nbsp;的结尾，用&nbsp;<code>*str2</code>&nbsp;替换&nbsp;<code>str1</code>&nbsp;末尾的&nbsp;<code>'\0'</code>&nbsp;返回&nbsp;<code>str1</code>。</td>
</tr>
<tr>
<td><code>strstr(char *str1, const char *str2)</code></td>
<td>若&nbsp;<code>str2</code>&nbsp;是&nbsp;<code>str1</code>&nbsp;的子串，则返回&nbsp;<code>str2</code>&nbsp;在&nbsp;<code>str1</code>&nbsp;的首次出现的地址；如果&nbsp;<code>str2</code>&nbsp;不是&nbsp;<code>str1</code>&nbsp;的子串，则返回&nbsp;<code>NULL</code>。</td>
</tr>
<tr>
<td><code>strchr(const char *str, int c)</code></td>
<td>找到在字符串&nbsp;<code>str</code>&nbsp;中第一次出现字符&nbsp;<code>c</code>&nbsp;的位置，并返回这个位置的地址。如果未找到该字符则返回&nbsp;<code>NULL</code>。</td>
</tr>
<tr>
<td><code>strrchr(const char *str, int c)</code></td>
<td>找到在字符串&nbsp;<code>str</code>&nbsp;中最后一次出现字符&nbsp;<code>c</code>&nbsp;的位置，并返回这个位置的地址。如果未找到该字符则返回&nbsp;<code>NULL</code>。</td>
</tr>
</tbody>
</table>
<h2 id="c标准库">C++标准库</h2>
<p>C++ 标准库操作字符串对象&nbsp;<a target="_blank" rel="noopener" href="https://oi-wiki.org/lang/csl/string/"><code>std::string</code></a>，同时也提供对字符数组的兼容。</p>
<table>
<colgroup>
<col style="width: 21%">
<col style="width: 78%">
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>重载了赋值运算符&nbsp;<code>+</code></td>
<td>当&nbsp;<code>+</code>&nbsp;两边是&nbsp;<code>string/char/char[]/const char*</code>&nbsp;类型时，可以将这两个变量连接，返回连接后的字符串（<code>string</code>）。</td>
</tr>
<tr>
<td>赋值运算符&nbsp;<code>=</code></td>
<td>右侧可以是&nbsp;<code>const string/string/const char*/char*</code></td>
</tr>
<tr>
<td>访问运算符&nbsp;<code>[cur]</code></td>
<td>返回&nbsp;<code>cur</code>&nbsp;位置的引用。</td>
</tr>
<tr>
<td>访问函数&nbsp;<code>data()/c_str()</code></td>
<td>返回一个&nbsp;<code>const char*</code>&nbsp;指针，内容与该&nbsp;<code>string</code>&nbsp;相同。</td>
</tr>
<tr>
<td>容量函数&nbsp;<code>size()</code></td>
<td>返回字符串字符个数</td>
</tr>
<tr>
<td><code>find(ch, start = 0)</code></td>
<td>查找并返回从&nbsp;<code>start</code>&nbsp;开始的字符&nbsp;<code>ch</code>&nbsp;的位置；</td>
</tr>
<tr>
<td><code>rfind(ch)</code></td>
<td>从末尾开始，查找并返回第一个找到的字符&nbsp;<code>ch</code>&nbsp;的位置（皆从&nbsp;<code>0</code>&nbsp;开始）（如果查找不到，返回&nbsp;<code>-1</code>）。</td>
</tr>
<tr>
<td><code>substr(start, len)</code></td>
<td>可以从字符串的&nbsp;<code>start</code>（从&nbsp;<code>0</code>&nbsp;开始）截取一个长度为&nbsp;<code>len</code>&nbsp;的字符串（缺省&nbsp;<code>len</code>&nbsp;时代码截取到字符串末尾）。</td>
</tr>
<tr>
<td><code>append(s)</code></td>
<td>将&nbsp;<code>s</code>&nbsp;添加到字符串末尾。</td>
</tr>
<tr>
<td><code>append(s, pos, n)</code></td>
<td>将字符串&nbsp;<code>s</code>&nbsp;中，从&nbsp;<code>pos</code>&nbsp;开始的&nbsp;<code>n</code>&nbsp;个字符连接到当前字符串结尾。</td>
</tr>
<tr>
<td><code>replace(pos, n, s)</code></td>
<td>删除从&nbsp;<code>pos</code>&nbsp;开始的&nbsp;<code>n</code>&nbsp;个字符，然后在&nbsp;<code>pos</code>&nbsp;处插入串&nbsp;<code>s</code>。</td>
</tr>
<tr>
<td><code>erase(pos, n)</code></td>
<td>删除从&nbsp;<code>pos</code>&nbsp;开始的&nbsp;<code>n</code>&nbsp;个字符。</td>
</tr>
<tr>
<td><code>insert(pos, s)</code></td>
<td>在&nbsp;<code>pos</code>&nbsp;位置插入字符串&nbsp;<code>s</code>。</td>
</tr>
</tbody>
</table>
<p><code>std::string</code>&nbsp;重载了比较逻辑运算符，复杂度是 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.529ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2444 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="398" d="M56 340Q56 423 86 494T164 610T270 680T388 705Q521 705 621 601T722 341Q722 260 693 191T617 75T510 4T388 -22T267 3T160 74T85 189T56 340ZM610 339Q610 428 590 495T535 598T463 651T384 668Q332 668 289 638T221 566Q168 485 168 339Q168 274 176 235Q189 158 228 105T324 28Q356 16 388 16Q415 16 442 24T501 54T555 111T594 205T610 339ZM223 263V422H263V388H514V422H554V263H514V297H263V263H223Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1167,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(2055,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>&nbsp;的。</p>
<h1 id="std-常用类型">std 常用类型</h1>
<h2 id="stdstring"><code>std::string</code></h2>
<p><code>std::string</code>&nbsp;是在标准库&nbsp;<code>&lt;string&gt;</code>（注意不是
C
语言中的&nbsp;<code>&lt;string.h&gt;</code>&nbsp;库）中提供的一个类，本质上是&nbsp;<code>std::basic_string&lt;char&gt;</code>&nbsp;的别称。</p>
<p>和许多 STL
容器相同，<code>string</code>&nbsp;能动态分配空间，这使得我们可以直接使用&nbsp;<code>std::cin</code>&nbsp;来输入，但其速度则同样较慢。这一点也同样让我们不必为内存而烦恼。</p>
<p><code>string</code>&nbsp;的加法运算符可以直接拼接两个字符串或一个字符串和一个字符。和&nbsp;<code>std::vector</code>&nbsp;类似，<code>string</code>&nbsp;重载了比较运算符，同样是按字典序比较的，所以我们可以直接调用&nbsp;<code>std::sort</code>&nbsp;对若干字符串进行排序。</p>
<p>在 C 语言里，也有很多字符串的函数，但是它们的参数都是 char
指针类型的，为了方便使用，<code>string</code>&nbsp;有两个成员函数能够将自己转换为
char
指针——<code>data()</code>/<code>c_str()</code>（它们几乎是一样的，但最好使用&nbsp;<code>c_str()</code>，因为&nbsp;<code>c_str()</code>&nbsp;保证末尾有空字符，而&nbsp;<code>data()</code>&nbsp;则不保证），如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, s); <span class="comment">// 编译错误 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, s.<span class="built_in">data</span>()); <span class="comment">// 编译通过，但是是 undefined behavior </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, s.<span class="built_in">c_str</span>()); <span class="comment">// 一定能够正确输出</span></span><br></pre></td></tr></tbody></table></figure>
<p>很多函数都可以返回 string 的长度：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"s 的长度为 %zu"</span>, s.<span class="built_in">size</span>()); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"s 的长度为 %zu"</span>, s.<span class="built_in">length</span>()); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"s 的长度为 %zu"</span>, <span class="built_in">strlen</span>(s.<span class="built_in">c_str</span>()));</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><code>strlen()</code>&nbsp;的复杂度一定是与字符串长度线性相关的。</p>
<p><code>size()</code>&nbsp;和&nbsp;<code>length()</code>&nbsp;的复杂度在 C++98
中没有指定，在 C++11 中被指定为常数复杂度。但在常见的编译器上，即便是
C++98，这两个函数的复杂度也是常数。</p>
</blockquote>
<blockquote>
<p>这三个函数（以及下面将要提到的&nbsp;<code>find</code>&nbsp;函数）的返回值类型都是&nbsp;<code>size_t</code>（<code>unsigned long</code>）。因此，这些返回值不支持直接与负数比较或运算，建议在需要时进行强制转换。</p>
</blockquote>
<h3 id="寻找某字符串-第一次出现的位置">寻找某字符(串)
第一次出现的位置</h3>
<p><code>find(str,pos)</code>&nbsp;函数可以用来查找字符串中一个字符/字符串在&nbsp;<code>pos</code>（含）之后第一次出现的位置（若不传参给&nbsp;<code>pos</code>&nbsp;则默认为&nbsp;<code>0</code>）。如果没有出现，则返回&nbsp;<code>string::npos</code>（被定义为&nbsp;<code>-1</code>，但类型仍为&nbsp;<code>size_t</code>/<code>unsigned long</code>）。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">"OI Wiki"</span>, t = <span class="string">"OI"</span>, u = <span class="string">"i"</span>; </span><br><span class="line"><span class="type">int</span> pos = <span class="number">5</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"字符 I 在 s 的 %lu 位置第一次出现\n"</span>, s.<span class="built_in">find</span>(<span class="string">'I'</span>)); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"字符 a 在 s 的 %lu 位置第一次出现\n"</span>, s.<span class="built_in">find</span>(<span class="string">'a'</span>)); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"字符 a 在 s 的 %d 位置第一次出现\n"</span>, s.<span class="built_in">find</span>(<span class="string">'a'</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"字符串 t 在 s 的 %lu 位置第一次出现\n"</span>, s.<span class="built_in">find</span>(t)); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"在 s 中自 pos 位置起字符串 u 第一次出现在 %lu 位置"</span>, s.<span class="built_in">find</span>(u, pos));</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字符 I 在 s 的 1 位置第一次出现 </span><br><span class="line">字符 a 在 s 的 18446744073709551615 位置第一次出现 // 即为 size_t(-1)，具体数值与平台有关。 </span><br><span class="line">字符 a 在 s 的 -1 位置第一次出现 // 强制转换为 int 类型则正常输出 -1 </span><br><span class="line">字符串 t 在 s 的 0 位置第一次出现 </span><br><span class="line">在 s 中自 pos 位置起字符串 u 第一次出现在 6 位置</span><br></pre></td></tr></tbody></table></figure>
<h3 id="截取子串">截取子串</h3>
<p><code>substr(pos, len)</code>&nbsp;函数的参数返回从&nbsp;<code>pos</code>&nbsp;位置开始截取最多&nbsp;<code>len</code>&nbsp;个字符组成的字符串（如果从&nbsp;<code>pos</code>&nbsp;开始的后缀长度不足&nbsp;<code>len</code>&nbsp;则截取这个后缀）。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">"OI Wiki"</span>, t = <span class="string">"OI"</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"从字符串 s 的第四位开始的最多三个字符构成的子串是 %s\n"</span>, s.<span class="built_in">substr</span>(<span class="number">3</span>, <span class="number">3</span>).<span class="built_in">c_str</span>()); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"从字符串 t 的第二位开始的最多三个字符构成的子串是 %s"</span>, t.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>).<span class="built_in">c_str</span>());</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从字符串 s 的第四位开始的最多三个字符构成的子串是 Wik </span><br><span class="line">从字符串 t 的第二位开始的最多三个字符构成的子串是 I</span><br></pre></td></tr></tbody></table></figure>
<h3 id="插入删除字符串">插入/删除字符(串)</h3>
<p><code>insert(index,count,ch)</code>&nbsp;和&nbsp;<code>insert(index,str)</code>&nbsp;是比较常见的插入函数。它们分别表示在&nbsp;<code>index</code>&nbsp;处连续插入&nbsp;<code>count</code>&nbsp;次字符串&nbsp;<code>ch</code>&nbsp;和插入字符串&nbsp;<code>str</code>。</p>
<p><code>erase(index,count)</code>&nbsp;函数将字符串&nbsp;<code>index</code>&nbsp;位置开始（含）的&nbsp;<code>count</code>&nbsp;个字符删除（若不传参给&nbsp;<code>count</code>&nbsp;则表示删去&nbsp;<code>index</code>&nbsp;位置及以后的所有字符）。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">"OI Wiki"</span>, t = <span class="string">" Wiki"</span>; </span><br><span class="line"><span class="type">char</span> u = <span class="string">'!'</span>; s.<span class="built_in">erase</span>(<span class="number">2</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"从字符串 s 的第三位开始删去所有字符后得到的字符串是 %s\n"</span>, s.<span class="built_in">c_str</span>()); </span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>, t); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"在字符串 s 的第三位处插入字符串 t 后得到的字符串是 %s\n"</span>, s.<span class="built_in">c_str</span>()); </span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">7</span>, <span class="number">3</span>, u); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"在字符串 s 的第八位处连续插入 3 次字符串 u 后得到的字符串是 %s"</span>, s.<span class="built_in">c_str</span>());</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从字符串 s 的第三位开始删去所有字符后得到的字符串是 OI </span><br><span class="line">在字符串 s 的第三位处插入字符串 t 后得到的字符串是 OI Wiki </span><br><span class="line">在字符串 s 的第八位处连续插入 3 次字符串 u 后得到的字符串是 OI Wiki!!!</span><br></pre></td></tr></tbody></table></figure>
<h3 id="替换字符串">替换字符(串)</h3>
<p><code>replace(pos,count,str)</code>&nbsp;和&nbsp;<code>replace(first,last,str)</code>&nbsp;是比较常见的替换函数。它们分别表示将从&nbsp;<code>pos</code>&nbsp;位置开始&nbsp;<code>count</code>&nbsp;个字符的子串替换为&nbsp;<code>str</code>&nbsp;以及将以&nbsp;<code>first</code>&nbsp;开始（含）、<code>last</code>&nbsp;结束（不含）的子串替换为&nbsp;<code>str</code>，其中&nbsp;<code>first</code>&nbsp;和&nbsp;<code>last</code>&nbsp;均为迭代器。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">"OI Wiki"</span>; s.<span class="built_in">replace</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="string">""</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"将字符串 s 的第 3~7 位替换为空串后得到的字符串是 %s\n"</span>, s.<span class="built_in">c_str</span>()); </span><br><span class="line">s.<span class="built_in">replace</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="string">"NOI"</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"将字符串 s 的前两位替换为 NOI 后得到的字符串是 %s"</span>, s.<span class="built_in">c_str</span>());</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将字符串 s 的第 3~7 位替换为空串后得到的字符串是 OI </span><br><span class="line">将字符串 s 的前两位替换为 NOI 后得到的字符串是 NOI</span><br></pre></td></tr></tbody></table></figure>
<h2 id="stdpair"><code>std::pair</code></h2>
<p>通过灵活使用&nbsp;<code>pair</code>，可以轻松应对&nbsp;<strong>需要将关联数据捆绑存储、处理</strong>&nbsp;的场景。</p>
<blockquote>
<p>与自定义的&nbsp;<code>struct</code>&nbsp;相比，<code>pair</code>&nbsp;不需要额外定义结构与重载运算符，因此使用起来更加简便。</p>
<p>然而，自定义&nbsp;<code>struct</code>&nbsp;的变量命名往往更加清晰（<code>pair</code>&nbsp;只能使用&nbsp;<code>first</code>&nbsp;与&nbsp;<code>second</code>&nbsp;访问包含的两个变量）。同时，如果需要将两个以上的变量进行关联，自定义&nbsp;<code>struct</code>&nbsp;会更加合适。</p>
</blockquote>
<h3 id="使用方法">使用方法</h3>
<p>可以在定义时直接完成&nbsp;<code>pair</code>&nbsp;的初始化。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p0</span><span class="params">(<span class="number">1</span>, <span class="number">2.0</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>也可以使用先定义，后赋值的方法完成&nbsp;<code>pair</code>&nbsp;的初始化。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p1; </span><br><span class="line">p<span class="number">1.f</span>irst = <span class="number">1</span>; </span><br><span class="line">p<span class="number">1.</span>second = <span class="number">2.0</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>还可以使用&nbsp;<code>std::make_pair</code>&nbsp;函数。该函数接受两个变量，并返回由这两个变量组成的&nbsp;<code>pair</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>通过成员函数&nbsp;<code>first</code>&nbsp;与&nbsp;<code>second</code>，可以访问&nbsp;<code>pair</code>&nbsp;中包含的两个变量。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = p<span class="number">0.f</span>irst; </span><br><span class="line"><span class="type">double</span> d = p<span class="number">0.</span>second;</span><br></pre></td></tr></tbody></table></figure>
<p>也可以对其进行修改</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p<span class="number">1.f</span>irst++;</span><br></pre></td></tr></tbody></table></figure>
<p><code>pair</code>&nbsp;已经预先定义了所有的比较运算符，包括&nbsp;<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>==</code>、<code>!=</code>。当然，这需要组成&nbsp;<code>pair</code>&nbsp;的两个变量所属的数据类型定义了&nbsp;<code>==</code>&nbsp;和/或&nbsp;<code>&lt;</code>&nbsp;运算符。</p>
<p>其中，<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>&nbsp;四个运算符会先比较两个&nbsp;<code>pair</code>&nbsp;中的第一个变量，在第一个变量相等的情况下再比较第二个变量。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p2 &gt;= p3) { </span><br><span class="line">	cout &lt;&lt; <span class="string">"do something here"</span> &lt;&lt; endl; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于&nbsp;<code>pair</code>&nbsp;定义了 STL
中常用的&nbsp;<code>&lt;</code>&nbsp;与&nbsp;<code>==</code>，使得其能够很好的与其他
STL
函数或数据结构配合。比如，<code>pair</code>&nbsp;可以作为&nbsp;<code>priority_queue</code>&nbsp;的数据类型。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">double</span>&gt;&gt; q;</span><br></pre></td></tr></tbody></table></figure>
<p>可以将&nbsp;<code>pair</code>&nbsp;的值赋给另一个类型一致的&nbsp;<code>pair</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p0 = p1;</span><br></pre></td></tr></tbody></table></figure>
<p>也可以使用&nbsp;<code>swap</code>&nbsp;函数交换&nbsp;<code>pair</code>&nbsp;的值。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(p0, p1); </span><br><span class="line">p<span class="number">2.</span><span class="built_in">swap</span>(p3);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="应用举例">应用举例</h3>
<h4 id="离散化">离散化</h4>
<p><code>pair</code>&nbsp;可以轻松实现离散化。</p>
<p>我们可以创建一个&nbsp;<code>pair</code>&nbsp;数组，将原始数据的值作为每个&nbsp;<code>pair</code>&nbsp;第一个变量，将原始数据的位置作为第二个变量。在排序后，将原始数据值的排名（该值排序后所在的位置）赋给该值原本所在的位置即可。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a为原始数据 </span></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a[MAXN]; </span><br><span class="line"><span class="comment">// ai为离散化后的数据 </span></span><br><span class="line"><span class="type">int</span> ai[MAXN]; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) { </span><br><span class="line">	<span class="comment">// first为原始数据的值，second为原始数据的位置 </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].first); a[i].second = i; </span><br><span class="line">} </span><br><span class="line"><span class="comment">// 排序 </span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n); </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) { </span><br><span class="line">	<span class="comment">// 将该值的排名赋给该值原本所在的位置 </span></span><br><span class="line">	ai[a[i].second] = i; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="dijkstra">Dijkstra</h4>
<p>如前所述，<code>pair</code>&nbsp;可以作为&nbsp;<code>priority_queue</code>&nbsp;的数据类型。</p>
<p>那么，在 Dijkstra
算法的堆优化中，可以使用&nbsp;<code>pair</code>&nbsp;与&nbsp;<code>priority_queue</code>&nbsp;维护节点，将节点当前到起点的距离作为第一个变量，将节点编号作为第二个变量。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, std::greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; q; </span><br><span class="line"></span><br><span class="line">	... <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) { </span><br><span class="line">	<span class="comment">// dis为入堆时节点到起点的距离，i为节点编号 </span></span><br><span class="line">	<span class="type">int</span> dis = q.<span class="built_in">top</span>().first, i = q.<span class="built_in">top</span>().second; </span><br><span class="line">	q.<span class="built_in">pop</span>(); </span><br><span class="line">	... </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="pair-与-map">pair 与 map</h4>
<p><code>map</code>&nbsp;的是 C++
中存储键值对的数据结构。很多情况下，<code>map</code>&nbsp;中存储的键值对通过&nbsp;<code>pair</code>&nbsp;向外暴露。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">double</span>&gt; m; </span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2.0</span>));</span><br></pre></td></tr></tbody></table></figure>
<h2 id="stdtuple"><code>std::tuple</code></h2>
<h3 id="简介">简介</h3>
<p>tuple是一个固定大小的不同类型值的集合，是泛化的std::pair。我们也可以把他当做一个通用的结构体来用，不需要创建结构体又获取结构体的特征，在某些情况下可以取代结构体使程序更简洁，直观。std::tuple理论上可以有无数个任意类型的成员变量，而std::pair只能是2个成员，因此在需要保存3个及以上的数据时就需要使用tuple元组了。</p>
<h3 id="创建与初始化">创建与初始化</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;T1, T2, TN&gt; t1;            </span><br><span class="line"><span class="comment">//创建一个空的tuple对象（使用默认构造），它对应的元素分别是T1和T2...Tn类型，采用值初始化。</span></span><br><span class="line"><span class="function">std::tuple&lt;T1, T2, TN&gt; <span class="title">t2</span><span class="params">(v1, v2, ... TN)</span></span>;    </span><br><span class="line"><span class="comment">//创建一个tuple对象，它的两个元素分别是T1和T2 ...Tn类型; 要获取元素的值需要通过tuple的成员get&lt;Ith&gt;(obj)进行获取(Ith是指获取在tuple中的第几个元素，请看后面具体实例)。</span></span><br><span class="line"><span class="function">std::tuple&lt;T1&amp;&gt; <span class="title">t3</span><span class="params">(ref&amp;)</span></span>; <span class="comment">// tuple的元素类型可以是一个引用</span></span><br><span class="line">std::<span class="built_in">make_tuple</span>(v1, v2); <span class="comment">// 像pair一样也可以通过make_tuple进行创建一个tuple对象</span></span><br></pre></td></tr></tbody></table></figure>
<p>&nbsp;tuple的元素类型为引用：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::string name;</span><br><span class="line"><span class="function">std::tuple&lt;string &amp;, <span class="type">int</span>&gt; <span class="title">tpRef</span><span class="params">(name, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="comment">// 对tpRef第一个元素赋值，同时name也被赋值 - 引用</span></span><br><span class="line">std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(tpRef) = <span class="string">"Sven"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// name输出也是Sven</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; name &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="有关tuple元素的操作">有关<code>tuple</code>元素的操作</h3>
<h4 id="等价结构体">等价结构体</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> {</span><br><span class="line">    <span class="type">char</span> *m_name;</span><br><span class="line">    <span class="type">char</span> *m_addr;</span><br><span class="line">    <span class="type">int</span>  *m_ages;</span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"><span class="comment">//可以用tuple来表示这样的一个结构类型，作用是一样的。</span></span><br><span class="line">std::tuple&lt;<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">int</span>&gt;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="获取tuple元素个数">获取tuple元素个数</h4>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tuple_size</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span>        <span class="comment">// std::tuple, std::tuple_size</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>, <span class="type">double</span>&gt; <span class="title">mytuple</span> <span class="params">(<span class="number">10</span>, <span class="string">'a'</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">"mytuple has "</span>;</span><br><span class="line">  std::cout &lt;&lt; std::tuple_size&lt;<span class="keyword">decltype</span>(mytuple)&gt;::value;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">" elements."</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">mytuple has <span class="number">3</span> elements</span><br></pre></td></tr></tbody></table></figure>
<h4 id="获取元素的值">获取元素的值</h4>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tuple_size</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span>        <span class="comment">// std::tuple, std::tuple_size</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>, <span class="type">double</span>&gt; <span class="title">mytuple</span> <span class="params">(<span class="number">10</span>, <span class="string">'a'</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">"mytuple has "</span>;</span><br><span class="line">  std::cout &lt;&lt; std::tuple_size&lt;<span class="keyword">decltype</span>(mytuple)&gt;::value;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">" elements."</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//获取元素</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"the elements is: "</span>;</span><br><span class="line">  std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(mytuple) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(mytuple) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">mytuple has <span class="number">3</span> elements.</span><br><span class="line">the elements is: <span class="number">10</span> a <span class="number">3.14</span> </span><br></pre></td></tr></tbody></table></figure>
<p>&nbsp;&nbsp;&nbsp;tuple不支持迭代，只能通过元素索引(或tie解包)进行获取元素的值。但是给定的索引必须是在编译器就已经给定，不能在运行期进行动态传递，否则将发生编译错误：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;i&gt;(mytuple) &lt;&lt; <span class="string">" "</span>; <span class="comment">//将引发编译错误</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="获取元素的类型">获取元素的类型</h4>
<p>要想得到元素类型可以通过tuple_element方法获取，如有以下元组对象：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>&gt; <span class="title">tp</span><span class="params">(<span class="string">"Sven"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 得到第二个元素类型</span></span><br><span class="line"> </span><br><span class="line">std::tuple_element&lt;<span class="number">1</span>, <span class="keyword">decltype</span>(tp)&gt;::type ages;  <span class="comment">// ages就为int类型</span></span><br><span class="line"> </span><br><span class="line">ages = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(tp);</span><br><span class="line"> </span><br><span class="line">std::cout &lt;&lt; <span class="string">"ages: "</span> &lt;&lt; ages &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//输出结果： </span></span><br><span class="line">ages: <span class="number">20</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="利用tie进行解包元素的值">利用tie进行解包元素的值</h4>
<p>&nbsp;如同pair一样也是可以通过tie进行解包tuple的各个元素的值。如下tuple对象有4个元素，通过tie解包将会把这4个元素的值分别赋值给tie提供的4个变量中。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>{</span><br><span class="line">    std::tuple&lt;std::string, <span class="type">int</span>, std::string, <span class="type">int</span>&gt; tp;</span><br><span class="line">    tp = std::<span class="built_in">make_tuple</span>(<span class="string">"Sven"</span>, <span class="number">25</span>, <span class="string">"Shanghai"</span>, <span class="number">21</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 定义接收变量</span></span><br><span class="line">    std::string name;</span><br><span class="line">    std::string addr;</span><br><span class="line">    <span class="type">int</span> ages;</span><br><span class="line">    <span class="type">int</span> areaCode;</span><br><span class="line"> </span><br><span class="line">    std::<span class="built_in">tie</span>(name, ages, addr, areaCode) = tp;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Output: "</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; name &lt;&lt;<span class="string">", "</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"addr: "</span> &lt;&lt; addr &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"ages: "</span> &lt;&lt; ages &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"areaCode: "</span> &lt;&lt; areaCode &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">Output: </span><br><span class="line">name: Sven, addr: Shanghai, ages: <span class="number">25</span>, areaCode: <span class="number">21</span></span><br></pre></td></tr></tbody></table></figure>
<p>但有时候tuple包含的多个元素时只需要其中的一个或两个元素，如此可以通过std::ignore进行变量占位，这样将会忽略提取对应的元素。可以修改上述例程：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>{</span><br><span class="line">    std::tuple&lt;std::string, <span class="type">int</span>, std::string, <span class="type">int</span>&gt; tp;</span><br><span class="line">    tp = std::<span class="built_in">make_tuple</span>(<span class="string">"Sven"</span>, <span class="number">25</span>, <span class="string">"Shanghai"</span>, <span class="number">21</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 定义接收变量</span></span><br><span class="line">    std::string name;</span><br><span class="line">    std::string addr;</span><br><span class="line">    <span class="type">int</span> ages;</span><br><span class="line">    <span class="type">int</span> areaCode = <span class="number">110</span>;</span><br><span class="line"> </span><br><span class="line">    std::<span class="built_in">tie</span>(name, ages, std::ignore, std::ignore) = tp;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Output: "</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; name &lt;&lt;<span class="string">", "</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"addr: "</span> &lt;&lt; addr &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"ages: "</span> &lt;&lt; ages &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"areaCode: "</span> &lt;&lt; areaCode &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">Output: </span><br><span class="line">name: Sven, addr: , ages: <span class="number">25</span>, areaCode: <span class="number">110</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="tuple元素的引用">tuple元素的引用</h4>
<p>前面已经列举了将引用作为tuple的元素类型。下面通过引用搭配make_tuple()可以提取tuple的元素值，将某些变量值设给它们，并通过改变这些变量来改变tuple元素的值：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **agrv)</span> </span>{</span><br><span class="line"> </span><br><span class="line">    <span class="function">std::tuple&lt;std::string, <span class="type">int</span>, <span class="type">float</span>&gt; <span class="title">tp1</span><span class="params">(<span class="string">"Sven Cheng"</span>, <span class="number">77</span>, <span class="number">66.1</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> tp2 = std::<span class="built_in">make_tuple</span>(std::<span class="built_in">ref</span>(name), std::<span class="built_in">ref</span>(weight), std::<span class="built_in">ref</span>(f)) = tp1;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Before change: "</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; name &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"weight: "</span> &lt;&lt; weight &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"f: "</span> &lt;&lt; f &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    name = <span class="string">"Sven"</span>;</span><br><span class="line">    weight = <span class="number">80</span>;</span><br><span class="line">    f = <span class="number">3.14</span>;</span><br><span class="line"> </span><br><span class="line">	std::cout &lt;&lt; <span class="string">"After change: "</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">"element 1st: "</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(tp2) &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">"element 2nd: "</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(tp2) &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">"element 3rd: "</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(tp2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">Before change: </span><br><span class="line">name: Sven Cheng, weight: <span class="number">77</span>, f: <span class="number">66.1</span></span><br><span class="line">After change: </span><br><span class="line">element <span class="number">1</span>st: Sven, element <span class="number">2</span>nd: <span class="number">80</span>, element <span class="number">3</span>rd: <span class="number">3.14</span></span><br></pre></td></tr></tbody></table></figure>

                    
                </div>

                
                        
<div class="post-copyright-info-container border-box">
    <div class="copyright-info-content border-box">
        <div class="copyright-info-top border-box">
            <div class="copyright-post-title border-box text-ellipsis">
                c++标准库
            </div>

            <div class="copyright-post-link border-box text-ellipsis">
                2024/11/20/others-oi-wiki-c-标准库/
            </div>
        </div>

        <div class="copyright-info-bottom border-box">
            <div class="copyright-post-author bottom-item">
                <div class="type">
                    Author
                </div>
                <div class="content">amor mío de mi vida</div>
            </div>

            <div class="post-time bottom-item">
                <div class="type">
                    Published
                </div>
                <div class="content">2024-11-20 09:01</div>
            </div>


            <div class="post-license bottom-item">
                <div class="type">
                    License
                </div>
                <div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0">
                    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed" target="_blank">
                        
                            <i class="fa-brands fa-creative-commons"></i>
                            <i class="fa-brands fa-creative-commons-by"></i>
                            <i class="fa-brands fa-creative-commons-nc"></i>
                            <i class="fa-brands fa-creative-commons-sa"></i>
                        
                    </a>
                </div>
            </div>
        </div>

        <i class="copyright-bg fa-solid fa-copyright"></i>
    </div>
    <div class="copy-copyright-info flex-center tooltip" data-tooltip-content="Copy copyright info" data-tooltip-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/oiwiki/">oiwiki</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                            <div class="post-share-container border-box">
    <ul class="share-list-wrap border-box">
        <li class="qq share-item border-box flex-center tooltip" data-tooltip-content="Share to QQ">
            <i class="fa-brands fa-qq"></i>
        </li>
        <li class="wechat share-item border-box flex-center tooltip tooltip-img" data-tooltip-content="Share to WeChat" data-tooltip-img-tip="Scan by WeChat" data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;">
            <i class="fa-brands fa-weixin"></i>
        </li>
        <li class="weibo share-item border-box flex-center tooltip" data-tooltip-content="Share to WeiBo">
            <i class="fa-brands fa-weibo"></i>
        </li>
    </ul>
</div>

                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev" rel="prev" href="/2024/11/20/others-oi-wiki-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" title="排序算法总结">
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">排序算法总结</span>
                                        <span class="post-nav-item">Prev posts</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next" rel="next" href="/2024/11/18/others-Principal-Component-Analysis-PCA%EF%BC%89/" title="Welcome to use Hexo Theme Keep">
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">Welcome to use Hexo Theme Keep</span>
                                        <span class="post-nav-item">Next posts</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#stl%E5%AE%B9%E5%99%A8"><span class="nav-text">STL容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="nav-text">序列式容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="nav-text">关联式容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="nav-text">无序(关联式)容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-text">容器适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E6%9C%89%E5%87%BD%E6%95%B0"><span class="nav-text">共有函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8-1"><span class="nav-text">序列式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-text">vector</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="nav-text">元素访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%BF%E5%BA%A6"><span class="nav-text">长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E9%87%8F"><span class="nav-text">容量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E5%A2%9E%E5%88%A0%E4%BB%A5%E5%8F%8A%E4%BF%AE%E6%94%B9"><span class="nav-text">元素增删以及修改</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#array-c11"><span class="nav-text">array (C++11)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">隐式定义的成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE-1"><span class="nav-text">元素访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E9%87%8F-1"><span class="nav-text">容量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C"><span class="nav-text">操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">非成员函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque"><span class="nav-text">deque</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE-2"><span class="nav-text">元素访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-1"><span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%BF%E5%BA%A6-1"><span class="nav-text">长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E5%A2%9E%E5%88%A0%E5%8F%8A%E4%BF%AE%E6%94%B9"><span class="nav-text">元素增删及修改</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-text">list</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE-3"><span class="nav-text">元素访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C-1"><span class="nav-text">操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forward_list"><span class="nav-text">forward_list</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-1"><span class="nav-text">关联式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-text">set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-text">插入与删除操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-2"><span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="nav-text">查找操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B"><span class="nav-text">使用样例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-text">map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-1"><span class="nav-text">插入与删除操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C"><span class="nav-text">查询操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B-1"><span class="nav-text">使用样例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E5%AE%B9%E5%99%A8"><span class="nav-text">遍历容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E6%96%B9%E5%BC%8F"><span class="nav-text">自定义比较方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-1"><span class="nav-text">无序关联式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%B6%E9%80%A0%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="nav-text">制造哈希冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="nav-text">自定义哈希函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8-1"><span class="nav-text">容器适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stack"><span class="nav-text">stack</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="nav-text">简单示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queue"><span class="nav-text">queue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-1"><span class="nav-text">成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">简单示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#priority_queue"><span class="nav-text">priority_queue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-2"><span class="nav-text">成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-2"><span class="nav-text">简单示例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#stl%E7%AE%97%E6%B3%95"><span class="nav-text">STL算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3stl"><span class="nav-text">排序相关STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#qsort"><span class="nav-text">qsort</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-text">函数原型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdsort"><span class="nav-text">std::sort</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95"><span class="nav-text">函数用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdnth_element"><span class="nav-text">std::nth_element</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95-1"><span class="nav-text">函数用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdstable_sort"><span class="nav-text">std::stable_sort</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95-2"><span class="nav-text">函数用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdpartial_sort"><span class="nav-text">std::partial_sort</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95-3"><span class="nav-text">函数用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83"><span class="nav-text">自定义比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96stl%E7%AE%97%E6%B3%95"><span class="nav-text">其他STL算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text">字符串标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text">C 标准库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text">C++标准库</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#std-%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-text">std 常用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#stdstring"><span class="nav-text">std::string</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E6%9F%90%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">寻找某字符(串)
第一次出现的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%AA%E5%8F%96%E5%AD%90%E4%B8%B2"><span class="nav-text">截取子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">插入/删除字符(串)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">替换字符(串)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stdpair"><span class="nav-text">std::pair</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-text">应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="nav-text">离散化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dijkstra"><span class="nav-text">Dijkstra</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pair-%E4%B8%8E-map"><span class="nav-text">pair 与 map</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stdtuple"><span class="nav-text">std::tuple</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">创建与初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%85%B3tuple%E5%85%83%E7%B4%A0%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">有关tuple元素的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%89%E4%BB%B7%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">等价结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96tuple%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="nav-text">获取tuple元素个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC"><span class="nav-text">获取元素的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">获取元素的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8tie%E8%BF%9B%E8%A1%8C%E8%A7%A3%E5%8C%85%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC"><span class="nav-text">利用tie进行解包元素的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tuple%E5%85%83%E7%B4%A0%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-text">tuple元素的引用</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
        ©&nbsp;<span>2020</span>&nbsp;-&nbsp;2024
        
            &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">amor mío de mi vida</a>
        
    </div>

    <div class="theme-info info-item">
        Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;&amp;&nbsp;Theme&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div>

    

    
        <div class="count-info info-item">
            

            
                <span class="count-item border-box uv">
                    <span class="item-type border-box">Unique Visitor</span>
                    <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span>
                </span>
            

            
                <span class="count-item border-box pv">
                    <span class="item-type border-box">Page View</span>
                    <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span>
                </span>
            
        </div>
    

    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <!-- toggle mode -->
        
            <li class="tools-item tool-toggle-theme-mode flex-center">
                <i class="fas fa-moon"></i>
            </li>
        

        <!-- rss -->
        

        <!-- to bottom -->
        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#stl%E5%AE%B9%E5%99%A8"><span class="nav-text">STL容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="nav-text">序列式容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="nav-text">关联式容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="nav-text">无序(关联式)容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-text">容器适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E6%9C%89%E5%87%BD%E6%95%B0"><span class="nav-text">共有函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8-1"><span class="nav-text">序列式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-text">vector</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="nav-text">元素访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%BF%E5%BA%A6"><span class="nav-text">长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E9%87%8F"><span class="nav-text">容量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E5%A2%9E%E5%88%A0%E4%BB%A5%E5%8F%8A%E4%BF%AE%E6%94%B9"><span class="nav-text">元素增删以及修改</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#array-c11"><span class="nav-text">array (C++11)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">隐式定义的成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE-1"><span class="nav-text">元素访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E9%87%8F-1"><span class="nav-text">容量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C"><span class="nav-text">操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">非成员函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque"><span class="nav-text">deque</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE-2"><span class="nav-text">元素访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-1"><span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%BF%E5%BA%A6-1"><span class="nav-text">长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E5%A2%9E%E5%88%A0%E5%8F%8A%E4%BF%AE%E6%94%B9"><span class="nav-text">元素增删及修改</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-text">list</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE-3"><span class="nav-text">元素访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C-1"><span class="nav-text">操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forward_list"><span class="nav-text">forward_list</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-1"><span class="nav-text">关联式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-text">set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-text">插入与删除操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-2"><span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="nav-text">查找操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B"><span class="nav-text">使用样例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-text">map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-1"><span class="nav-text">插入与删除操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C"><span class="nav-text">查询操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B-1"><span class="nav-text">使用样例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E5%AE%B9%E5%99%A8"><span class="nav-text">遍历容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E6%96%B9%E5%BC%8F"><span class="nav-text">自定义比较方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-1"><span class="nav-text">无序关联式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%B6%E9%80%A0%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="nav-text">制造哈希冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="nav-text">自定义哈希函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8-1"><span class="nav-text">容器适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stack"><span class="nav-text">stack</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="nav-text">简单示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queue"><span class="nav-text">queue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-1"><span class="nav-text">成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">简单示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#priority_queue"><span class="nav-text">priority_queue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-2"><span class="nav-text">成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-2"><span class="nav-text">简单示例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#stl%E7%AE%97%E6%B3%95"><span class="nav-text">STL算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3stl"><span class="nav-text">排序相关STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#qsort"><span class="nav-text">qsort</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-text">函数原型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdsort"><span class="nav-text">std::sort</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95"><span class="nav-text">函数用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdnth_element"><span class="nav-text">std::nth_element</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95-1"><span class="nav-text">函数用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdstable_sort"><span class="nav-text">std::stable_sort</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95-2"><span class="nav-text">函数用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdpartial_sort"><span class="nav-text">std::partial_sort</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95-3"><span class="nav-text">函数用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83"><span class="nav-text">自定义比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96stl%E7%AE%97%E6%B3%95"><span class="nav-text">其他STL算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text">字符串标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text">C 标准库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text">C++标准库</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#std-%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-text">std 常用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#stdstring"><span class="nav-text">std::string</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E6%9F%90%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">寻找某字符(串)
第一次出现的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%AA%E5%8F%96%E5%AD%90%E4%B8%B2"><span class="nav-text">截取子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">插入/删除字符(串)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">替换字符(串)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stdpair"><span class="nav-text">std::pair</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-text">应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="nav-text">离散化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dijkstra"><span class="nav-text">Dijkstra</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pair-%E4%B8%8E-map"><span class="nav-text">pair 与 map</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stdtuple"><span class="nav-text">std::tuple</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">创建与初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%85%B3tuple%E5%85%83%E7%B4%A0%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">有关tuple元素的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%89%E4%BB%B7%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">等价结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96tuple%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="nav-text">获取tuple元素个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC"><span class="nav-text">获取元素的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">获取元素的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8tie%E8%BF%9B%E8%A1%8C%E8%A7%A3%E5%8C%85%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC"><span class="nav-text">利用tie进行解包元素的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tuple%E5%85%83%E7%B4%A0%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-text">tuple元素的引用</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>





<!-- common js -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local search -->

    
<script src="/js/local-search.js"></script>



<!-- lazyload -->

    
<script src="/js/lazyload.js"></script>



<div class="pjax">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        
            
<script src="/js/post/toc.js"></script>

        

        <!-- copyright-info -->
        
            
<script src="/js/post/copyright-info.js"></script>

        

        <!-- share -->
        
            
<script src="/js/post/share.js"></script>

        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->

    
<script src="//cdn.jsdelivr.net/npm/mermaid@10.5.0/dist/mermaid.min.js"></script>

    <script data-pjax="">
      if (window.mermaid) {
        mermaid.init()
      }
    </script>






<!-- pjax -->

    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart()
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd()
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'))
            KEEP.initExecute()
        });
    });
</script>






<script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>