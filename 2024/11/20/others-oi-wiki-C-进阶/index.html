<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="amor mío de mi vida">
    
    <title>
        
            C++进阶 |
        
        Hesen's Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/avatar.svg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en","path":"search.xml"}
    KEEP.theme_config = {"title":"Keep","subtitle":"Hexo theme keep quick starter","description":"","keywords":null,"author":"Keep Team","language":"en","timezone":"","url":"http://example.com","permalink":":year/:month/:day/:name/","permalink_defaults":null,"pretty_urls":{"trailing_index":true,"trailing_html":true},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":"","wrap":true,"hljs":false},"prismjs":{"enable":false,"preprocess":true,"line_number":true,"tab_replace":""},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"meta_generator":true,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","updated_option":"mtime","per_page":10,"pagination_dir":"page","include":null,"exclude":null,"ignore":null,"theme":"keep","deploy":{"type":""},"search":{"path":"search.json","field":"post","content":true,"format":"striptags"},"feed":{"type":"atom","path":"atom.xml","limit":20},"math":{"perpage":true,"mathjax":{"enable":true,"mhchem":false}},"root":"","base_info":{"primary_color":"#0066cc","title":"Hesen's Blog","author":"amor mío de mi vida","avatar":"/images/avatar.svg","logo":"/images/avatar.svg","favicon":"/images/avatar.svg"},"menu":{"home":"/                       || fa-solid fa-home","archives":"/archives           || fa-solid fa-box-archive","tags":"/tags                   || fa-solid fa-tags","categories":"/categories       || fa-solid fa-layer-group","about":"/about                 || fa-solid fa-user","github":"https://github.com/amor-mio-de-mi-vida || fa-brands fa-github"},"first_screen":{"enable":true,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Audentis fortuna iuvat.","hitokoto":false},"social_contact":{"enable":true,"links":{"github":"https://github.com/amor-mio-de-mi-vida","weixin":"img |","qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":true,"hide_header":true},"home":{"announcement":null,"category":true,"tag":true,"post_datetime":"updated"},"post":{"author_badge":{"enable":true,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":true,"min2read":true},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":true,"share":true,"reward":{"enable":false,"img_link":null,"text":null}},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":true,"site_pv":true,"page_pv":true}},"local_search":{"enable":true,"preload":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.36"},"waline":{"server_url":null,"reaction":false,"version":"3.2.1"},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":true},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":true},"footer":{"since":2020,"word_count":false,"site_deploy":{"enable":false,"provider":"github","url":null},"record":{"enable":false,"list":[{"code":null,"link":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"source_data":{},"version":"4.2.3"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original post title","author":"Original post author","link":"Original post link"}
  </script>
<meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left flex-start border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/avatar.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               Hesen's Blog
            </a>
        </div>

        <div class="right border-box">
            <div class="pc border-box">
                <ul class="menu-list border-box">
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-home"></i>
                                
                                HOME
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/archives">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-box-archive"></i>
                                
                                ARCHIVES
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/tags">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-tags"></i>
                                
                                TAGS
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/categories">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-layer-group"></i>
                                
                                CATEGORIES
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/about">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-user"></i>
                                
                                ABOUT
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" target="_blank" rel="noopener" href="https://github.com/amor-mio-de-mi-vida">
                                
                                    <i class="menu-text-color menu-icon fa-brands fa-github"></i>
                                
                                GITHUB
                                
                            </a>
                            
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="menu-text-color fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile border-box flex-start">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list border-box">
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-home"></i>
                                </span>
                            
                            HOME
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/archives">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-box-archive"></i>
                                </span>
                            
                            ARCHIVES
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/tags">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-tags"></i>
                                </span>
                            
                            TAGS
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/categories">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-layer-group"></i>
                                </span>
                            
                            CATEGORIES
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/about">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-user"></i>
                                </span>
                            
                            ABOUT
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" target="_blank" rel="noopener" href="https://github.com/amor-mio-de-mi-vida">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-brands fa-github"></i>
                                </span>
                            
                            GITHUB
                        </a>
                        
                    </label>
                    
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        C++进阶
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/avatar.svg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">amor mío de mi vida</span>
                                
                                    <span class="author-badge">Lv4</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-11-20 18:13:38</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Sat Nov 30 2024 10:58:13 GMT+0800">2024-11-30 10:58:13</span>
            </span>
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/cpp/">cpp</a></li>
                        
                    
                </ul>
            </span>
        

        
            <span class="post-tag meta-info-item border-box">
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/cpp/">cpp</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item post-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>10.8k Words</span>
            </span>
        
        
            <span class="meta-info-item post-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>45 Mins</span>
            </span>
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <h1 id="值类别">值类别</h1>
<h2 id="不必要的复制">不必要的复制</h2>
<p>我们考虑将字符串塞入 vector 这一过程：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	std::vector&lt;std::string&gt; vec;</span><br><span class="line">	vec.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</span><br><span class="line">		std::string str;</span><br><span class="line">		std::cin &gt;&gt; str;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(str);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以发现字符串在转移的过程中，在&nbsp;<code>str</code>&nbsp;和&nbsp;<code>vec</code>&nbsp;中各保存了一份，内存占用加倍。</p>
<p>如果非要省下这一部分的内存，我们可以实现一个简陋的移动操作：自定义&nbsp;<code>MyString</code>&nbsp;结构体，内有一指针指向我们的字符串，即我们只需要把指针复制过去，并小心地清理原对象的指针，防止被错误析构。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyString</span> {</span><br><span class="line">	<span class="type">char</span> *beg, *end;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move_to</span><span class="params">(MyString &amp;src, Mystring &amp;dst)</span> </span>{</span><br><span class="line">	dst.beg = src.beg;</span><br><span class="line">	dst.end = src.end;</span><br><span class="line">	src.beg = src.end = <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于这种高效转移对象的需求较为常见，且与 C++
的构造、析构等操作交互困难，C++11 将移动语义引入了语言核心。</p>
<h2 id="c语言中的值类别">C语言中的值类别</h2>
<p>在 C
语言标准中，对象是一个比变量更为一般化的概念，它指代一块内存区域，具有内存地址。对象的主要属性包括：大小、有效类型、值和标识符。标识符即变量名，值是该内存以其类型解释时的含义。例如，<code>int</code>&nbsp;和&nbsp;<code>float</code>&nbsp;类型虽然都占用
4 字节，但对于同一块内存，我们会解释出不同的含义。</p>
<p>C 语言中每个表达式都具有类型和值类别。值类别主要分为三类：</p>
<ul>
<li><p>左值（lvalue）：隐含指代一个对象的表达式。即我们可以对该表达式取地址。</p></li>
<li><p>右值（rvalue）：不指代对象的表达式，即指代没有存储位置的值，我们无法取该值的地址。</p></li>
<li><p>函数指代符：函数类型的表达式。</p></li>
</ul>
<p>因此，只有可修改的左值（没有&nbsp;<code>const</code>&nbsp;修饰且非数组的左值）可以位于赋值表达式左侧。</p>
<p>对于某个要求右值作为它的操作数的运算符，每当左值被用作操作数，都会对该表达式应用左值到右值，数组到指针，或者函数到指针标准转换以将它转换成右值。</p>
<p>常见误区：</p>
<ul>
<li><p>右值表达式继续运算可能是左值。例如&nbsp;<code>int *a</code>，表达式&nbsp;<code>a + 1</code>&nbsp;是右值，但&nbsp;<code>*(a + 1)</code>&nbsp;是左值。</p></li>
<li><p>表达式才有值类别，变量没有。例如&nbsp;<code>int *a</code>，不能说变量&nbsp;<code>a</code>&nbsp;是左值，可以说其在表达式&nbsp;<code>a</code>&nbsp;中做左值，</p></li>
</ul>
<h2 id="c98中的值的类别">C++98中的值的类别</h2>
<p>C++98 在值类别方面与 C 语言几乎一致，但增加了一些新的规则：</p>
<ul>
<li><p>函数为左值，因为可以取地址。</p></li>
<li><p>左值引用（T&amp;）是左值，因为可以取地址。</p></li>
<li><p>仅有&nbsp;<code>const T&amp;</code>&nbsp;可绑定到右值。</p></li>
</ul>
<h3 id="复制消除">复制消除</h3>
<p>C++ 允许编译器执行复制消除（Copy
Elision），可以减少临时对象的创建和销毁。</p>
<p>例如下面的代码，就触发了复制消除中的返回值优化（Return Value
Optimization，RVO），你只会看到一次构造和一次复制构造，即便构造与析构有副作用。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> {</span><br><span class="line">	<span class="built_in">X</span>() { std::<span class="built_in">puts</span>(<span class="string">"X::X()"</span>); }</span><br><span class="line">	<span class="built_in">X</span>(<span class="type">const</span> X &amp;) { std::<span class="built_in">puts</span>(<span class="string">"X::X(const X &amp;)"</span>); }</span><br><span class="line">	~<span class="built_in">X</span>() { std::<span class="built_in">puts</span>(<span class="string">"X::~X()"</span>); }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">	X x;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	X x = <span class="built_in">get</span>();</span><br><span class="line">	X y = <span class="built_in">X</span>(<span class="built_in">X</span>(<span class="built_in">X</span>(<span class="built_in">X</span>(x))));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="c11-中值的类别">C++11 中值的类别</h2>
<p>C++11
引入了移动语义和右值引用（<code>T&amp;&amp;</code>），包括移动构造、移动赋值函数。这给了我们利用临时对象的方法。</p>
<p>我们上面的&nbsp;<code>move_to</code>&nbsp;可以改写如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyString</span> {</span><br><span class="line">	<span class="comment">// ... </span></span><br><span class="line">	<span class="built_in">MyString</span>(MyString&amp;&amp; other) {</span><br><span class="line">		beg = other.beg;</span><br><span class="line">		end = other.end;</span><br><span class="line">		other.beg = other.end = <span class="literal">nullptr</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>我们现在关注的表达式特性增加了一点：</p>
<ul>
<li><p>是否具有身份：是否指代一个对象，即是否有地址。</p></li>
<li><p>是否可被移动：是否具有移动构造、移动赋值等函数，让我们有办法利用这些临时对象。</p></li>
</ul>
<p>因此我们有三种值类别：</p>
<ul>
<li><p>有身份，不可移动：左值（lvalue）。</p></li>
<li><p>有身份，可被移动：亡值（xvalue）。</p></li>
<li><p>无身份，可被移动：纯右值（prvalue）。</p></li>
<li><p>无身份，不可移动：此类表达式无法使用。</p></li>
</ul>
<p>另外 C++11 还引入了两个复合类别：</p>
<ul>
<li><p>具有身份：泛左值（glvalue），即左值和亡值。</p></li>
<li><p>可被移动：右值（rvalue），即纯右值和亡值。</p></li>
</ul>
<h3 id="stdmove">std::move</h3>
<p>为了配合移动语义，C++11
还引入了一个工具函数&nbsp;<code>std::move</code>，其作用是将左值强制转换为右值，以便触发移动语义。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; a = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">	std::cout &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; std::endl;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; b = a;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">"b: "</span> &lt;&lt; b.<span class="built_in">data</span>() &lt;&lt; std::endl;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; c = std::<span class="built_in">move</span>(b);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">"c: "</span> &lt;&lt; c.<span class="built_in">data</span>() &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因此我们只需将&nbsp;<code>push_back(str)</code>&nbsp;改为&nbsp;<code>push_back(std::move(str))</code>&nbsp;即可避免复制。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	std::vector&lt;std::string&gt; vec;</span><br><span class="line">	vec.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</span><br><span class="line">		std::string str;</span><br><span class="line">		std::cin &gt;&gt; str;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str));</span><br><span class="line">		<span class="comment">// 另一种巧妙的写法，需要 C++17</span></span><br><span class="line">		<span class="comment">// std::cin &gt;&gt; vec.emplace_back();</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于&nbsp;<code>std::string</code>&nbsp;有小对象优化（Small String
Optimization，SSO），短字符串直接存储于结构体内，你可能得输入较长的字符串才能观察到&nbsp;<code>data</code>&nbsp;指针的不变性。</p>
<h2 id="c17-中的值类别">C++17 中的值类别</h2>
<p>C++17 进一步简化了值类别：</p>
<ul>
<li>左值（lvalue）：有身份，不可移动。</li>
<li>亡值（xvalue）：有身份，可以移动。</li>
<li>纯右值（prvalue）：对象的初始化。</li>
</ul>
<p>C++11
将复制消除扩展到了移动上，下面的代码中&nbsp;<code>urvo</code>&nbsp;在编译器启用
RVO 的情况下是没有移动的。</p>
<p>C++17
要求纯右值非必须不实质化，直接构造到其最终目标的存储中，在构造之前对象尚不存在。因此在
C++17 中我们就没有返回这一步，也就不必依赖 RVO。也可以理解为强制了
URVO（Unnamed RVO），但对于 NRVO（Named RVO）还是非强制的。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">urvo</span><span class="params">()</span> </span>{ <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">"123"</span>); }</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">nrvo</span><span class="params">()</span> </span>{</span><br><span class="line">	std::string s;</span><br><span class="line">	s = <span class="string">"123"</span>;</span><br><span class="line">	std::cout &lt;&lt; s;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	std::string str = <span class="built_in">urvo</span>();  <span class="comment">// 直接构造</span></span><br><span class="line">	std::string str = <span class="built_in">nrvo</span>();  <span class="comment">// 不一定直接构造，依赖于优化</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>同时 C++17
引入了临时量实质化的机制，当我们需要访问成员变量、调用成员函数等需要泛左值的情形时，可以隐式转换为亡值。</p>
<h3 id="常见误区">常见误区<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/lang/value-category/#%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA" title="Permanent link"><i class="fas fa-external-link-alt"></i></a></h3>
<p>下面的例子中：</p>
<ul>
<li>在&nbsp;<code>f1</code>&nbsp;中返回&nbsp;<code>std::move(x)</code>&nbsp;是多余的，并不会带来性能上的提升，反而会干扰编译器进行
NRVO 优化。</li>
<li>在&nbsp;<code>f2</code>&nbsp;中返回&nbsp;<code>std::move(x)</code>&nbsp;是危险的，函数返回右值引用指向了已被销毁的局部变量&nbsp;<code>s</code>，出现了悬空引用问题。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">f1</span><span class="params">()</span> </span>{</span><br><span class="line">	std::string s = <span class="string">"123"</span>;</span><br><span class="line">	<span class="comment">// 等价于 return std::string(std::move(s))</span></span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">move</span>(s);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::string string&amp;&amp; <span class="title">f2</span><span class="params">()</span> </span>{</span><br><span class="line">	std::string s = <span class="string">"123"</span>;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">move</span>(s);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="重载运算符">重载运算符</h1>
<p>重载运算符是通过对运算符的重新定义，使得其支持特定数据类型的运算操作。重载运算符是重载函数的特殊情况。</p>
<blockquote>
<p>当一个运算符出现在一个表达式中，并且运算符的至少一个操作数具有一个类或枚举的类型时，则使用重载决议（overload
resolution）确定应该调用哪个满足相应声明的用户定义函数。<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/lang/op-overload/#fn:ref1">1<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>通俗的讲，如果把使用「运算符」看作一个调用特殊的函数（如将&nbsp;<code>1+2</code>&nbsp;视作调用&nbsp;<code>add(1, 2)</code>），并且这个函数的参数（操作数）至少有一个是&nbsp;<code>class</code>、<code>struct</code>&nbsp;或&nbsp;<code>enum</code>&nbsp;的类型，编译器就需要根据操作数的类型决定应当调用哪个自定义函数。</p>
<p>在 C++ 中，我们可以重载几乎所有可用的运算符。</p>
<h2 id="限制">限制</h2>
<p>重载运算符存在如下限制：</p>
<ul>
<li><p>只能对现有的运算符进行重载，不能自行定义新的运算符。</p></li>
<li><p>以下运算符不能被重载：<code>::</code>（作用域解析），<code>.</code>（成员访问），<code>.*</code>（通过成员指针的成员访问），<code>?:</code>（三目运算符）。</p></li>
<li><p>重载后的运算符，其运算优先级，运算操作数，结合方向不得改变。</p></li>
<li><p>对&nbsp;<code>&amp;&amp;</code>（逻辑与）和&nbsp;<code>||</code>（逻辑或）的重载失去短路求值。</p></li>
</ul>
<h2 id="实现">实现</h2>
<p>重载运算符分为两种情况，重载为成员函数或非成员函数。</p>
<p>当重载为成员函数时，因为隐含一个指向当前成员的&nbsp;<code>this</code>&nbsp;指针作为参数，此时函数的参数个数与运算操作数相比少一个。</p>
<p>而当重载为非成员函数时，函数的参数个数与运算操作数相同。</p>
<p>其基本格式为（假设需要被重载的运算符为&nbsp;<code>@</code>）：</p>
<h2 id="基本算数运算符">基本算数运算符</h2>
<p>下面定义了一个二维向量结构体&nbsp;<code>Vector2D</code>&nbsp;并实现了相应的加法和内积的重载。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2D</span> {</span><br><span class="line">	<span class="type">double</span> x, y;</span><br><span class="line">	<span class="built_in">Vector2D</span> (<span class="type">double</span> a = <span class="number">0</span>, <span class="type">double</span> b = <span class="number">0</span>) : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) {}</span><br><span class="line">	Vector2D <span class="keyword">operator</span>+(Vector <span class="number">2</span>D v) <span class="type">const</span> { <span class="keyword">return</span> <span class="built_in">Vector2D</span>(x + v.x, y + v.y); }</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 注意返回值的类型可以不是这个类</span></span><br><span class="line">	<span class="type">double</span> <span class="keyword">operator</span>*(Vector2D v) <span class="type">const</span> { <span class="keyword">return</span> x * v.x + y * v.y; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="自增自减运算符">自增自减运算符</h3>
<p>自增自减运算符分为两类，前置（<code>++a</code>）和后置（<code>a++</code>）。为了区分前后置运算符，重载后置运算时需要添加一个类型为&nbsp;<code>int</code>&nbsp;的空置形参。</p>
<p>可以将前置自增理解为调用&nbsp;<code>operator++(a)</code>&nbsp;或&nbsp;<code>a.operator++()</code>，后置自增理解为调用&nbsp;<code>operator++(a, 0)</code>&nbsp;或&nbsp;<code>a.operator++(0)</code>。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyInt</span> {</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="comment">// 前置，对应 ++a</span></span><br><span class="line">	MyInt &amp;<span class="keyword">operator</span>++() {</span><br><span class="line">		x++;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 后置，对应 a++ </span></span><br><span class="line">	MyInt <span class="keyword">operator</span>++(<span class="type">int</span>) {</span><br><span class="line">		MyInt tmp;</span><br><span class="line">		tmp.x = x;</span><br><span class="line">		x++;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>另外一点是，内置的自增自减运算符中，前置的运算符返回的是引用，而后置的运算符返回的是值。虽然重载后的运算符不必遵循这一限制，不过在语义上，仍然期望重载的运算符与内置的运算符在返回值的类型上保持一致。</p>
<p>对于类型 T，典型的重载自增运算符的定义如下：</p>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 37%">
<col style="width: 41%">
</colgroup>
<thead>
<tr>
<th>重载定义(以<code>++</code>为例)</th>
<th>成员函数</th>
<th>非成员函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>前置</td>
<td><code>T&amp; T::operator++();</code></td>
<td><code>T&amp; operator++(T&amp; a);</code></td>
</tr>
<tr>
<td>后置</td>
<td><code>T T::operator++(int);</code></td>
<td><code>T operator++(T&amp; a, int);</code></td>
</tr>
</tbody>
</table>
<h3 id="函数调用运算符">函数调用运算符</h3>
<p>函数调用运算符&nbsp;<code>()</code>&nbsp;只能重载为成员函数。通过对一个类重载&nbsp;<code>()</code>&nbsp;运算符，可以使该类的对象能像函数一样调用。</p>
<p>重载&nbsp;<code>()</code>&nbsp;运算符的一个常见应用是，将重载了&nbsp;<code>()</code>&nbsp;运算符的结构体作为自定义比较函数传入优先队列等
STL 容器中。</p>
<p>下面就是一个例子：给出&nbsp;<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span>&nbsp;个学生的姓名和分数，按分数降序排序，分数相同者按姓名字典序升序排序，输出排名最靠前的人的姓名和分数。</p>
<p>下面定义了一个比较结构体，实现自定义优先队列的排序方式。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> {</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmo</span> {</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> student&amp; a, <span class="type">const</span> student&amp; b)</span> <span class="type">const</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> a.score &lt; b.score || (a.score == b.score &amp;&amp; a.name &gt; b.name);</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意传入的模版参数为结构体名称而非实例</span></span><br><span class="line">priority_queue&lt;student, vector&lt;student&gt;, cmp&gt; pq;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="比较运算符">比较运算符</h3>
<p>在&nbsp;<code>std::sort</code>&nbsp;和一些 STL
容器中，需要用到&nbsp;<code>&lt;</code>&nbsp;运算符。在使用自定义类型时，我们需要手动重载。</p>
<p>下面是一个例子，实现了和上一节相同的功能</p>
<p>重载比较运算符的例子</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> {</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 重载 &lt; 号运算符</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> student&amp; a) <span class="type">const</span> {</span><br><span class="line">		<span class="keyword">return</span> score &lt; a.score || (score == a.score &amp;&amp; name &gt; a.name);</span><br><span class="line">		<span class="comment">// 上面忽略了 this 指针，完整表达式如下：</span></span><br><span class="line">		<span class="comment">// this-&gt;score &lt; a.score || (this-&gt;score == a.score &amp;&amp; this-&gt;name &gt; a.name)</span></span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">priority_queue&lt;student&gt; pq;</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码将小于号重载为了成员函数，当然重载为非成员函数也是可以的。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> { </span><br><span class="line">	string name; </span><br><span class="line">	<span class="type">int</span> score; </span><br><span class="line">}; </span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> student&amp; a, <span class="type">const</span> student&amp; b) { </span><br><span class="line">	<span class="keyword">return</span> a.score &lt; b.score || (a.score == b.score &amp;&amp; a.name &gt; b.name); </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">priority_queue&lt;student&gt; pq;</span><br></pre></td></tr></tbody></table></figure>
<p>事实上，只要有了 <code>&lt;</code>
运算符，则其他五个比较运算符的重载也可以很容易实现</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* clang-format off */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的几种实现均将小于号重载为非成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="built_in">operator</span>&lt;(<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs) { <span class="comment">/* 这里重载小于运算符*/</span> }</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs) { <span class="keyword">return</span> rhs &lt; lhs; }</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs) { <span class="keyword">return</span> !(lhs &gt; rhs); }</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs) { !(lhs &lt; rhs); }</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> T&amp; lhs, <span class="type">const</span> ^&amp; rhs) { <span class="keyword">return</span> !(lhs &lt; rhs) &amp;&amp; !(lhs &gt; rhs); }</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs) { <span class="keyword">return</span> !(lhs==rhs); }</span><br></pre></td></tr></tbody></table></figure>
<p>如果使用 c++20
或更高的版本，我们可以直接使用默认三路比较运算符简化代码。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs) = <span class="keyword">default</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>默认比较的顺序按照成员变量声明的顺序逐个比较。<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/lang/op-overload/#fn:ref4">4<i class="fas fa-external-link-alt"></i></a></p>
<p>也可以使用自定义三路比较。此时要求选择比较内含的序关系（<code>std::strong_ordering</code>、<code>std::weak_ordering</code>&nbsp;或&nbsp;<code>std::partial_ordering</code>），或者返回一个对象，使得：</p>
<ul>
<li><p>若&nbsp;<code>a &lt; b</code>，则&nbsp;<code>(a &lt;=&gt; b) &lt; 0</code>；</p></li>
<li><p>若&nbsp;<code>a &gt; b</code>，则&nbsp;<code>(a &lt;=&gt; b) &gt; 0</code>；</p></li>
<li><p>若&nbsp;<code>a</code>&nbsp;和&nbsp;<code>b</code>&nbsp;相等或等价，则&nbsp;<code>(a &lt;=&gt; b) == 0</code>。</p></li>
</ul>
<h1 id="引用">引用</h1>
<blockquote>
<p>声明具名变量为引用，即既存对象或函数的别名。</p>
</blockquote>
<p>引用可以看成是 C++
封装的非空指针，可以用来传递它所指向的对象，在声明时必须指向对象。</p>
<p>引用不是对象，因此不存在引用的数组、无法获取引用的指针，也不存在引用的引用。</p>
<blockquote>
<p><strong>引用类型不属于对象类型</strong></p>
<p>如果想让引用能完成一般的复制、赋值等操作，比如作为容器元素，则需要&nbsp;<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/utility/functional/reference_wrapper"><code>reference_wrapper</code></a>，通常维护一个非空指针实现。</p>
</blockquote>
<p>引用主要分为两种，左值引用和右值引用</p>
<h2 id="左值引用-t">左值引用 <code>T&amp;</code></h2>
<p>通常我们会接触到的引用为左值引用，即绑定到左值的引用，同时&nbsp;<code>const</code>&nbsp;限定的左值引用可以绑定右值。以下是来自&nbsp;<a class="link" target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/reference">参考手册<i class="fas fa-external-link-alt"></i></a>&nbsp;的一段示例代码。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	std::string s = <span class="string">"Ex"</span>;</span><br><span class="line">	std::string&amp; r1 = s;</span><br><span class="line">	<span class="type">const</span> std::string&amp; r2 = s;</span><br><span class="line">	r1 += <span class="string">"ample"</span>; <span class="comment">// 修改了 r1 ，即修改了 s</span></span><br><span class="line">	<span class="comment">// r2 += "!"  // 错误：不能通过到 const 的引用修改</span></span><br><span class="line">	std::out &lt;&lt; r2 &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 打印了 r2,访问了 s, 输出 "Example"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>左值引用最常用的地方是函数参数，用于避免不需要的拷贝。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数中的 s 是引用，在调用函数时不会发生拷贝</span></span><br><span class="line"><span class="function"><span class="type">char</span>&amp; <span class="title">chad_number</span><span class="params">(std::string&amp; s, std::<span class="type">size_t</span> n)</span> </span>{</span><br><span class="line">	s += s; <span class="comment">// 's' 与 main() 的 'str' 是同一对象，此处还说明左值也是可以放在等号右侧的</span></span><br><span class="line">	<span class="keyword">return</span> s.<span class="built_in">at</span>(n); <span class="comment">// string::at() 返回 char 的引用</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	std::string str  = <span class="string">"Test"</span>;</span><br><span class="line">	<span class="built_in">char_number</span>(str, <span class="number">1</span>) = <span class="string">'a'</span>; <span class="comment">// 函数返回是左值。可被赋值</span></span><br><span class="line">	std::cout &lt;&lt; str &lt;&lt; <span class="string">"\n"</span>; <span class="comment">// 此处输出 "TastTest"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="右值引用-t-c-11">右值引用 <code>T&amp;&amp;</code> C++ 11</h2>
<p>右值引用是绑定到右值的引用，用于移动对象，也可以用于<strong>延长临时对象生存期</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	string s1 = <span class="string">"Test"</span>;</span><br><span class="line">	<span class="comment">// string&amp;&amp; r1 = s1; // 错误：不能绑定到左值，需要 std::move 或者 static_cast</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">const</span> string&amp; r2 = s1 + s1; <span class="comment">// 可行：到常量的左值引用延长生存期</span></span><br><span class="line">	<span class="comment">// r2 += "Test"; // 错误：不能通过到常量的引用修改</span></span><br><span class="line">	cout &lt;&lt; r2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	</span><br><span class="line">	string&amp;&amp; r3 = s1 + s1; <span class="comment">// 可行：右值引用延长生存期</span></span><br><span class="line">	r3 += <span class="string">"Test"</span>;</span><br><span class="line">	cout &lt;&lt; r3 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">const</span> string&amp; r4 = r3; <span class="comment">// 右值引用可以转换到 const 限定的左值</span></span><br><span class="line">	cout &lt;&lt; r4 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	</span><br><span class="line">	string&amp; r5 = r3; <span class="comment">// 右值引用可以转换到左值</span></span><br><span class="line">	cout &lt;&lt; r5 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="悬垂引用">悬垂引用</h2>
<p>当引用指代的对象已经销毁，引用就会变成悬垂引用，访问悬垂引用这是一种未定义行为，可能会导致程序崩溃。</p>
<p>以下为常见的悬垂引用的例子：</p>
<ul>
<li>引用局部变量</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">foo</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="type">int</span>&amp; b = <span class="built_in">foo</span>();</span><br><span class="line">	std::cout &lt;&lt; b &lt;&lt; std::endl; <span class="comment">// 未定义行为</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>解分配导致的悬垂引用</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="type">int</span>&amp; ref = *ptr;</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">	</span><br><span class="line">	std::cout &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>内存重分配导致的悬垂引用</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	std::string str = <span class="string">"hello"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>&amp; ref = str.<span class="built_in">front</span>();</span><br><span class="line">	</span><br><span class="line">	str.<span class="built_in">append</span>(<span class="string">"world"</span>); <span class="comment">// 可能会重新分配内存，导致 ref 指向的内存被释放</span></span><br><span class="line">	</span><br><span class="line">	std::cout &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>类似 <code>std::vector</code>, <code>std::unordered_map</code>
等容器的插入操作，均有可能导致内存重新分配。</p>
<p>使用引用时，应时刻关注引用指向的对象的生命周期，避免造成悬垂引用。</p>
<p>通常静态检查工具和良好的代码习惯能让我们避免悬垂引用的问题。</p>
<h2 id="引用相关的优化技巧">引用相关的优化技巧</h2>
<h3 id="消除非轻量对象入参的拷贝开销">消除非轻量对象入参的拷贝开销</h3>
<p>常见的<strong>非轻量对象</strong>有：</p>
<ul>
<li><p>容器 <code>vector</code>, <code>array</code>, <code>map</code>
等</p></li>
<li><p><code>string</code></p></li>
<li><p>其他实现了或继承了自定义拷贝构造、移动构造等特殊函数的类型</p></li>
</ul>
<p>而对<strong>轻量对象</strong>使用引用不能带来任何好处，引用类型作为参数的空间占用大小，甚至可能会比类型本身还大。</p>
<p>这可能会带来些性能的负担，同时可能会阻止编译器优化。</p>
<p>以下属于<strong>轻量对象</strong></p>
<ul>
<li><p>基本类型 <code>int</code>, <code>float</code> 等</p></li>
<li><p>较小的聚合体类型</p></li>
<li><p>标准库容器的迭代器</p></li>
</ul>
<h3 id="将左值转换为右值">将左值转换为右值</h3>
<p>使用 <code>std::move</code>
转移对象的所有权。这通常见于局部变量之间，或参数与局部变量之间：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">world</span><span class="params">(string str)</span> </span>{ <span class="keyword">return</span> std::<span class="built_in">move</span>(str) += <span class="string">"world"</span>; }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="comment">// 1</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">world</span>(<span class="string">"hello"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	</span><br><span class="line">	vector&lt;string&gt; vec0;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2</span></span><br><span class="line">	{</span><br><span class="line">		string &amp;&amp; size = <span class="built_in">to_string</span>(vec<span class="number">0.</span><span class="built_in">size</span>());</span><br><span class="line">		</span><br><span class="line">		size += <span class="string">", "</span> + <span class="built_in">to_string</span>(size.<span class="built_in">size</span>());</span><br><span class="line">		</span><br><span class="line">		vec<span class="number">0.</span><span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(size));</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; vec<span class="number">0.f</span>ront();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>### 右值延长临时量生命期<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/lang/reference/#%E5%8F%B3%E5%80%BC%E5%BB%B6%E9%95%BF%E4%B8%B4%E6%97%B6%E9%87%8F%E7%94%9F%E5%91%BD%E6%9C%9F" title="Permanent link"><i class="fas fa-external-link-alt"></i></a></p>
<p>从语义上，临时量可能会带来的额外的复制或移动，尽管多数情况下编译器能通过&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/lang/value-category/#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除<i class="fas fa-external-link-alt"></i></a>&nbsp;进行优化，但引用能强制编译器不进行这些多余操作，避免不确定性。</p>
<h1 id="常量">常量</h1>
<p>C++定义了一套完整的只读量定义方法，被 <code>const</code>
修饰的变量都是只读量，编译器会在编译期进行冲突检查，避免对只读量的修改，同时可能会执行一些优化。</p>
<p>在通常情况下，应该尽可能用 <code>const</code>
修饰变量、参数，提高代码的健壮性。</p>
<h3 id="const-类型限定符"><code>const</code> 类型限定符</h3>
<h2 id="常量-1">常量</h2>
<p>const 修饰的变量在初始化后不可改变值</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>; <span class="comment">// a 的类型为 const int </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a = 1; // 不能修改常量</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="常量引用常量指针">常量引用、常量指针</h2>
<p>常量引用和常量指针均限制了对指向值的修改</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p1 = &amp;a;</span><br><span class="line">*p1 = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;a;</span><br><span class="line"><span class="comment">// *p2 = 2； // 不能通过常量指针修改变量;</span></span><br><span class="line"><span class="comment">// int *p3 = &amp;b  // 不能用 int* 指向 const int 变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p4 = &amp;b;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;r1 = a;</span><br><span class="line">r1 = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = a;</span><br><span class="line"><span class="comment">// r2 = 2; // 不能通过常量引用修改变量</span></span><br><span class="line"><span class="comment">// int &amp;p3 = b; // 不能用 int&amp; 引用 const int 变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r4 = b;</span><br></pre></td></tr></tbody></table></figure>
<p>另外需要区分开的是常量指针 (<code>const t*</code>) 和指针常量
(<code>t* const</code>), 例如下列声明</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> p1; <span class="comment">// 指针常量，初始化后指向地址不可改，可更改指向的值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p2; <span class="comment">// 常量指针，解引用的值不可改，可指向其他 int 变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p3; <span class="comment">// 常量指针常量，值不可改，指向地址不可改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用别名能更好提高可读性</span></span><br><span class="line"><span class="keyword">using</span> const_int = <span class="type">const</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> ptr_to_const_int = const_int*;</span><br><span class="line"><span class="keyword">using</span> const_ptr_to_const_int = <span class="type">const</span> ptr_to_const_int;</span><br></pre></td></tr></tbody></table></figure>
<p>在函数参数里使用 <code>const</code>
限定参数类型，可以避免变量被错误的修改，同时增加代码可读性</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;data, <span class="type">int</span> &amp;total)</span> </span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> iter = data.<span class="built_in">begin</span>(); iter != data.<span class="built_in">end</span>(); iter++) </span><br><span class="line">		total += *iter; <span class="comment">// iter 是迭代器，解引用后的类型是 const int</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="const-成员函数"><code>const</code> 成员函数</h2>
<p>类型中 <code>const</code>
限定的成员函数，可以用来限制对成员的修改。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConstMember</span> {</span><br><span class="line">	<span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{ std::cout &lt;&lt; <span class="string">"General Function "</span> &lt;&lt; std::endl; }</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">constFunc1</span><span class="params">()</span> <span class="type">const</span> </span>{ std::cout &lt;&lt; <span class="string">"Const Function 1"</span> &lt;&lt; std::endl; }</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">constFunc2</span><span class="params">(<span class="type">int</span> ss)</span> <span class="type">const</span> </span>{</span><br><span class="line">		<span class="comment">// func(); // const 成员函数不能调用非 const 成员函数</span></span><br><span class="line">		<span class="built_in">constFunc1</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// s = ss; // const 成员函数不能修改成员变量</span></span><br><span class="line">	} </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">	ConstMember c{};</span><br><span class="line">	<span class="type">const</span> ConstMember d = c;</span><br><span class="line">	<span class="comment">// d.func();  // 常量不能调用非 const 成员函数</span></span><br><span class="line">	d.<span class="built_in">constFunc2</span>(b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="常量表达式-constexpr">常量表达式 <code>constexpr</code></h2>
<p>常量表达式是指编译时能计算出结果的表达式，<code>constexpr</code>
则要求编译器能在编译时求得函数或变量的值。</p>
<p>编译时计算能允许更好的优化，比如将结果硬编码到汇编中，消除运行时计算开销。与
<code>const</code> 的带来的优化不同，当 <code>constexpr</code>
修饰的变量满足常量表达式的条件，就强制要求编译器在编译时计算出结果而非运行时。</p>
<blockquote>
<p>实际上把 <code>const</code> 理解成 <code>readonly</code>,
<code>constexpr</code> 理解成 <code>const</code>, 这样更加直观</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">10</span>; <span class="comment">// 直接定义常量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">FivePlus</span><span class="params">(<span class="type">int</span> x)</span> </span>{ <span class="keyword">return</span> <span class="number">5</span> + x; }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x)</span> </span>{</span><br><span class="line">	std::array&lt;x&gt; c1; <span class="comment">// 错误 x 编译时不可知</span></span><br><span class="line">	std::array&lt;FivePlus(6)&gt; c2; <span class="comment">// 可行，FivePlus编译时可知</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>以下例子很好说明了 <code>const</code> 和 <code>constexpr</code>
的区别，代码使用递归实现计算斐波那契数列，并用控制流输出。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="title">fib0</span><span class="params">(<span class="type">unsigned</span> n)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : (<span class="built_in">fib0</span>(n - <span class="number">1</span>) + <span class="built_in">fib0</span>(n - <span class="number">2</span>)); </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">fib1</span><span class="params">(<span class="type">unsigned</span> n)</span> </span>{ <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : (<span class="built_in">fib1</span>(n - <span class="number">1</span>) + <span class="built_in">fib1</span>(n - <span class="number">2</span>)); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">auto</span> v0 = <span class="built_in">fib0</span>(<span class="number">9</span>);</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> v1 = <span class="built_in">fib1</span>(<span class="number">9</span>);</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; v0;</span><br><span class="line">	cout &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	cout &lt;&lt; v1;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><code>constexpr</code>&nbsp;修饰的&nbsp;<code>fib0</code>&nbsp;函数在唯一的调用处用了常量参数，使得整个函数仅在编译期运行。由于函数没有运行时执行，编译器也就判断不需要生成汇编代码。</p>
<p>在同时注意到汇编中，<code>v0</code>&nbsp;没有初始化代码，在调用&nbsp;<code>cout</code>&nbsp;输出&nbsp;<code>v0</code>&nbsp;的代码中，<code>v0</code>&nbsp;已被最终结算结果替代，说明变量值已在编译时求出，优化掉了运行时运算。
而&nbsp;<code>v1</code>&nbsp;的初始化还是普通的&nbsp;<code>fib1</code>&nbsp;递归调用。</p>
<p>所以&nbsp;<code>constexpr</code>&nbsp;可以用来替换宏定义的常量，规避&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/lang/basic/#define-%E5%91%BD%E4%BB%A4">宏定义的风险<i class="fas fa-external-link-alt"></i></a>。</p>
<p>算法题中可以使用&nbsp;<code>constexpr</code>&nbsp;存储数据规模较小的变量，以消除对应的运行时计算开销。尤为常见在「<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/contest/dictionary/">打表<i class="fas fa-external-link-alt"></i></a>」技巧中，使用&nbsp;<code>constexpr</code>&nbsp;修饰的数组等容器存储答案。</p>
<blockquote>
<p>编译时计算量过大会导致编译错误，编译器会限制编译时计算的开销，如果计算量过大会导致无法通过编译，应该考虑使用
<code>const</code>.</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">fib</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> i &lt;= <span class="number">2</span> ? i : <span class="built_in">fib</span>(i - <span class="number">2</span>) + <span class="built_in">fib</span>(i - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="comment">// constexpr auto v = fib(32); evaluation exceeded maximum depth</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> v = <span class="built_in">fib</span>(<span class="number">32</span>);</span><br><span class="line">	cout &lt;&lt; v;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="新版的-c-特性">新版的 C++ 特性</h1>
<p>本文语法参照 c++11 标准。语义不同的将以 c++11
作为标准，c++14，c++17等语法视情况提及并会特别标注。</p>
<h2 id="auto-类型说明符"><code>auto</code> 类型说明符</h2>
<p><code>auto</code> 类型说明符用于自动推导变量等的类型。例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">1</span>; <span class="comment">// a 是 int 类型</span></span><br><span class="line"><span class="keyword">auto</span> b = a + <span class="number">0.1</span>; <span class="comment">// b 是 double 类型</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="基于范围的-for-循环">基于范围的 <code>for</code> 循环</h2>
<p>下面是一种简单的基于范围的 <code>for</code> 循环的语法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (range_declaration: range_expression) loop_statement</span><br></pre></td></tr></tbody></table></figure>
<p>上述语法产生的代码等价于下列代码 (<code>__range</code>,
<code>__begin</code> 和 <code>__end</code> 仅用于阐释)：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; __range = range_expression;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> __begin = begin_expr, __end = end_expr; __begin != __end; ++__begin) {</span><br><span class="line">	range_declaration = *__begin;</span><br><span class="line">	loop_statement</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="range_declaration-范围声明">range_declaration 范围声明</h3>
<p>范围声明是一个具名变量的声明，其类型是由范围表达式所表示的序列的元素的类型，或该类型的引用。通常用&nbsp;<code>auto</code>&nbsp;说明符进行自动类型推导。</p>
<h3 id="range_expression-范围表达式">range_expression 范围表达式</h3>
<p>范围表达式是任何可以表示一个合适的序列（数组，或定义了&nbsp;<code>begin</code>&nbsp;和&nbsp;<code>end</code>&nbsp;成员函数或自由函数的对象）的表达式，或一个花括号初始化器列表。正因此，我们不应在循环体中修改范围表达式使其任何尚未被遍历到的「迭代器」（包括「尾后迭代器」）非法化。</p>
<p>这里有一个例子：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i: {<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>}) std::cout &lt;&lt; i;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="loop_statement-循环语句">loop_statement 循环语句</h3>
<p>循环语句可以是任何语句，常为一条复合语句，它是循环体。</p>
<p>这里有一个例子：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> {</span><br><span class="line">	<span class="type">int</span> a, b, c, d;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">C</span>(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>, <span class="type">int</span> c = <span class="number">0</span>, <span class="type">int</span> d = <span class="number">0</span>) : <span class="built_in">a</span>(a), <span class="built_in">b</span>(b), <span class="built_in">c</span>(c), <span class="built_in">d</span>(d) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">begin</span><span class="params">(C&amp; p)</span> </span>{ <span class="keyword">return</span> &amp;p.a; }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">end</span><span class="params">(C&amp; p)</span> </span>{ <span class="keyword">return</span> &amp;p.d + <span class="number">1</span>; }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	C n = <span class="built_in">C</span>(<span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : n) std::cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">	<span class="comment">// 下面的循环与上面的循环等价</span></span><br><span class="line">	<span class="keyword">auto</span>&amp;&amp; __range = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> __begin = <span class="built_in">begin</span>(n), __end = <span class="built_in">end</span>(n); __begin != __end; ++__begin) {</span><br><span class="line">		<span class="keyword">auto</span> ind = *__begin;</span><br><span class="line">		std::cout &lt;&lt; ind &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="初始化语句c20">初始化语句（C++20）</h3>
<p>在 C++20 中，范围循环中可以使用初始化语句：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; v = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> n = v.<span class="built_in">size</span>(); <span class="keyword">auto</span> i: v) <span class="comment">// the init-statement (c++20)</span></span><br><span class="line">		std::cout &lt;&lt; --n + i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="函数对象">函数对象</h2>
<p>函数对象相较于函数指针，具有更高的灵活性，能够保存状态，也能够作为参数传递给其他函数。在函数中使用函数对象，仅需要将参数类型定义为模板参数，就能允许任意函数对象传入。</p>
<p>它不是一种语言特性，而是一种&nbsp;<a class="link" target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/named_req/FunctionObject">概念或者要求<i class="fas fa-external-link-alt"></i></a>，在标准库中广泛应用。</p>
<p>在通常的实现中，函数对象（FunctionObject）重载了&nbsp;<code>operator()</code>，使得其实例能够像函数一样被调用，而&nbsp;<a class="link" target="_blank" rel="noopener" href="https://oi-wiki.org/lang/lambda/">lambda<i class="fas fa-external-link-alt"></i></a>&nbsp;即为一种典型的函数对象。</p>
<h2 id="范围库c20">范围库（C++20）</h2>
<blockquote>
<p>范围库是对迭代器和泛型算法库的一个扩展，使得迭代器和算法可以通过组合变得更强大，并且减少错误。</p>
</blockquote>
<p>范围即可遍历的序列，包括数组、容器、视图等。</p>
<p>在需要对容器等范围进行复杂操作时，<a class="link" target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/ranges">范围库<i class="fas fa-external-link-alt"></i></a>&nbsp;可以使得算法编写更加容易和清晰。</p>
<h3 id="view-视图"><code>View</code> 视图</h3>
<p>视图是一种轻量对象，通过特定机制（如自定义迭代器）来实现一些算法，给范围提供了更多的遍历方式以满足需求。</p>
<p>范围库中已实现了一些常用的视图，大致分为两种：</p>
<ol type="1">
<li><p><strong>范围工厂</strong>，用于构造一些特殊的范围工厂，使用这类工厂可以省去手动构造容器的步骤，降低开销，直接生成一个范围。</p></li>
<li><p><strong>范围适配器</strong>，提供多种多样的遍历支持，既能像函数一样调用，也可以通过管道运算符&nbsp;<code>|</code>&nbsp;连接，实现链式调用。</p></li>
</ol>
<p><strong>范围适配器</strong>&nbsp;作为&nbsp;<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/named_req/RangeAdaptorClosureObject"><strong>范围适配器闭包对象</strong></a>，也属于&nbsp;<a target="_blank" rel="noopener" href="https://oi-wiki.org/lang/new/#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><strong>函数对象</strong></a>，它们重载了&nbsp;<code>operator|</code>，使得它们能够像管道一样拼装起来。</p>
<blockquote>
<p>此处的&nbsp;<code>|</code>&nbsp;应该理解成管道运算符，而非按位或运算符，这个用法来自于
Linux 中的&nbsp;<a class="link" target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_//(Unix//)">管道<i class="fas fa-external-link-alt"></i></a>。</p>
</blockquote>
<p>在复杂操作下，也能保持良好可读性，有以下特性：</p>
<p>若 A、B、C 为一些范围适配器闭包对象，R
为某个范围，其他字母为可能的有效参数，表达式</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R | <span class="built_in">A</span>(a) | <span class="built_in">B</span>(b) | <span class="built_in">C</span>(c, d)</span><br></pre></td></tr></tbody></table></figure>
<p>等价于</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">C</span>(<span class="built_in">B</span>(<span class="built_in">A</span>(R, a), b), c, d)</span><br></pre></td></tr></tbody></table></figure>
<p>下面以 <code>ranges::take_view</code> 与
<code>ranges::iota_view</code> 为例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> even = [](<span class="type">int</span> i) { <span class="keyword">return</span> <span class="number">0</span> == i % <span class="number">2</span>; };</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i : std::views::<span class="built_in">iota</span>(<span class="number">0</span>, <span class="number">6</span>) | std::views::<span class="built_in">filter</span>(even)) </span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol type="1">
<li><p>范围工厂&nbsp;<code>std::views::iota(0, 6)</code>&nbsp;生成了从 1 到 6
的整数序列的范围</p></li>
<li><p>范围适配器&nbsp;<code>std::views::filter(even)</code>&nbsp;过滤前一个范围，生成了一个只剩下偶数的范围</p></li>
<li><p>两个操作使用管道运算符链接</p></li>
</ol>
<p>上述代码不需要额外分配堆空间存储每步生成的范围，实际的生成和过滤运算发生在遍历操作中（更具体而言，内部的迭代器构造、自增和解引用），也就是零开销（Zero
Overhead）。</p>
<p>同时，外部输入的范围生命周期，等同于&nbsp;<strong>范围适配器</strong>&nbsp;的内部元素的生命周期。如果外部范围（比如容器、范围工厂）已经销毁，那么再对这些的视图遍历，其效果与解引用悬垂指针一致，属于未定义行为。</p>
<p>为了避免上述情况，应该严格要求适配器的生命周期位于其使用的任何范围的生命周期内。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">auto</span> view = [] {</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; vec{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">		<span class="keyword">return</span> vec | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> i) { <span class="keyword">return</span> <span class="number">0</span> == i % <span class="number">2</span>; });</span><br><span class="line">	}();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i: view) cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>; <span class="comment">// runtime undefined behavior</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="constrained-algorithm-受约束的算法">Constrained Algorithm
受约束的算法</h2>
<blockquote>
<p>C++20 在命名空间 std::ranges
中提供大多数算法的受约束版本，可以用迭代器 - 哨位对或单个 range
作为实参来指定范围，并且支持投影和指向成员指针可调用对象。另外还更改了大多数算法的返回类型，以返回算法执行过程中计算的所有潜在有用信息。</p>
</blockquote>
<p>这些算法可以理解成旧标准库算法的改良版本，均为函数对象，提供更友好的重载和入参类型检查（基于&nbsp;<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/constraints"><code>concept</code></a>），让我们先以&nbsp;<code>std::sort</code>&nbsp;和&nbsp;<code>ranges::sort</code>&nbsp;的对比作为例子</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec{<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>};</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()); <span class="comment">// {1, 2, 3, 4, 5}</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> i: vec) cout &lt;&lt; i &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	</span><br><span class="line">	ranges::<span class="built_in">sort</span>(vec, ranges::greater{}); <span class="comment">// {5, 4, 3, 2, 1}</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> i : vec) cout &lt;&lt; i &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><code>ranges::sort</code>&nbsp;和&nbsp;<code>sort</code>&nbsp;的算法实现相同，但提供了基于范围的重载，使得传参更为简洁。其他的&nbsp;<code>std</code>&nbsp;命名空间下的算法，多数也有对应的范围重载版本位于&nbsp;<code>ranges</code>&nbsp;命名空间中。</p>
<p>使用这些范围入参，再结合使用上节视图，能允许我们在进行复杂操作的同时，保持代码可读性，让我们看一个例子：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span>&amp; inputs = views::<span class="built_in">itoa</span>(<span class="number">0u</span>, <span class="number">9u</span>); <span class="comment">// 生产 0 到 8 的整数序列</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span>&amp; chunks = inputs | views::<span class="built_in">chunk</span>(<span class="number">3</span>); <span class="comment">// 将序列分块，每块 3 个元素</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span>&amp; cartesian_product = views::<span class="built_in">cartesian_product</span>(chunks, chunks); <span class="comment">// 计算对块自身进行笛卡尔积</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> [l_chunk, r_chunk] : cartesian_product)</span><br><span class="line">		<span class="comment">// 计算笛卡尔积下的两个块整数的和</span></span><br><span class="line">		cout &lt;&lt; ranges::<span class="built_in">fold_left</span>(l_chunk, <span class="number">0u</span>, plus{}) + ranges::<span class="built_in">fold_left</span>(r_chunk, <span class="number">0u</span>, plus{}) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="decltype-说明符">decltype 说明符</h2>
<p><code>decltype</code>&nbsp;说明符可以推断表达式的类型。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1926</span>;</span><br><span class="line">	<span class="keyword">decltype</span>(a) b = a / <span class="number">2</span> - <span class="number">146</span>; <span class="comment">// b 是 int 类型</span></span><br><span class="line">	std::vector&lt;<span class="keyword">decltype</span>(b)&gt; vec = {<span class="number">0</span>}; <span class="comment">// vec 是 std::vector&lt;int&gt; 类型</span></span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="stdfunction">std::function</h2>
<blockquote>
<p><strong>请注意性能开销</strong></p>
<p><code>std::function</code>
会引入一定的性能开销，通常会造成2到3倍以上的性能损失。
因为他使用了类型擦除的技术，而这通常借由虚函数机制实现，调用虚函数会引入额外的开销。
请考虑使用 <code>lambda</code> 表达式或者 <code>函数对象</code> 代替</p>
</blockquote>
<p><code>std::function</code> 是通用函数封装器，定义于头文件
<code>&lt;functional&gt;</code>。</p>
<p><code>std::function</code>
的实例能存储、复制及调用任何可调用对象，这包括
<code>Lambda 表达式</code>、成员函数指针或其他
<code>函数对象</code>。</p>
<p>若 <code>std::function</code> 不含任何可调用对象
(比如默认构造)，调用时导致抛出 <code>std::bad_function_call</code>
异常。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> {</span><br><span class="line">	<span class="built_in">Foo</span>(<span class="type">int</span> num) : <span class="built_in">num_</span>(num) {}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print_add</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span> </span>{ std::cout &lt;&lt; num_ + i &lt;&lt; <span class="string">"\n"</span>; }</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> num_;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_num</span><span class="params">(<span class="type">int</span> i)</span> </span>{ std::cout &lt;&lt; i &lt;&lt; <span class="string">"\n"</span>; }</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PrintNum</span> {</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span> </span>{ std::cout &lt;&lt; i &lt;&lt; <span class="string">"\n"</span>; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="comment">// 存储自由函数</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; f_display = print_num;</span><br><span class="line">	<span class="built_in">f_display</span>(<span class="number">-9</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存储 Lambda</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>()&gt; f_display_42 = []() { <span class="built_in">print_num</span>(<span class="number">42</span>); };</span><br><span class="line">	<span class="built_in">f_display_42</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存储到成员函数的调用</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>(<span class="type">const</span> Foo&amp;, <span class="type">int</span>)&gt; f_add_display = &amp;Foo::print_add;</span><br><span class="line">	<span class="function"><span class="type">const</span> Foo <span class="title">foo</span><span class="params">(<span class="number">314159</span>)</span></span>;</span><br><span class="line">	<span class="built_in">f_add_display</span>(foo, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">f_add_display</span>(<span class="number">314159</span>, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存储到数据成员访问器的调用</span></span><br><span class="line">	std::function&lt;<span class="type">int</span>(Foo <span class="type">const</span>&amp;)&gt; f_num = &amp;Foo::num_;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">"num_:"</span> &lt;&lt; <span class="built_in">f_num</span>(foo) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存储到函数对象的调用</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; f_display_obj = <span class="built_in">PrintNum</span>();</span><br><span class="line">	<span class="built_in">f_display_obj</span>(<span class="number">18</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="stdtuple-元组">std::tuple 元组</h2>
<p>定义于头文件&nbsp;<code>&lt;tuple&gt;</code>，即&nbsp;<a class="link" target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%85%83%E7%BB%84">元组<i class="fas fa-external-link-alt"></i></a>，是&nbsp;<code>std::pair</code>&nbsp;的推广，下面来看一个例子：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> expr = <span class="number">1</span> + <span class="number">1</span> * <span class="number">4</span> - <span class="number">5</span> - <span class="number">1</span> + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>};</span><br><span class="line">	std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, std::string, std::vector&lt;<span class="type">int</span>&gt;&gt; tup = std::<span class="built_in">make_tuple</span>(<span class="number">817</span>, <span class="number">114</span>, <span class="string">"514"</span>, vec);</span><br><span class="line">	std::cout &lt;&lt; std::tuple_size_v&lt;<span class="keyword">decltype</span>(tup)&gt; &lt;&lt; sed::endl; <span class="comment">// 元组包含的类型数量</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : std::<span class="built_in">get</span>&lt;expr&gt;(tup)) std::cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="comment">// std::get&lt;&gt; 中尖括号里面的必须是整型常量表达式</span></span><br><span class="line">	<span class="comment">// expr 常量的值是 3， 注意 std::tuple 的首元素编号为0，</span></span><br><span class="line">	<span class="comment">// 故我们 std::get 到了一个 std::vector&lt;int&gt;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operator=</code></td>
<td>赋值一个 <code>tuple</code> 的内容给另一个</td>
</tr>
<tr>
<td><code>swap</code></td>
<td>交换两个 <code>tuple</code> 的内容</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tup = {<span class="number">1</span>, <span class="number">2</span>};</span><br><span class="line">std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tupA = {<span class="number">2</span>, <span class="number">3</span>}, tupB;</span><br><span class="line">tupB = tup;</span><br><span class="line">tupB.<span class="built_in">swap</span>(tupA);</span><br></pre></td></tr></tbody></table></figure>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>make_tuple</code></td>
<td>创建一个 <code>tuple</code> 对象，其类型根据各实参类型定义</td>
</tr>
<tr>
<td><code>std::get</code></td>
<td>元组式访问指定的元素</td>
</tr>
<tr>
<td><code>operator==</code> 等</td>
<td>按字典序比较 <code>tuple</code> 中的值</td>
</tr>
<tr>
<td><code>std::swap</code></td>
<td>特化的 <code>std::swap</code> 算法</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tupA = {<span class="number">2</span>, <span class="number">3</span>}, tupB;</span><br><span class="line">tupB = std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">std::<span class="built_in">swap</span>(tupA, tupB);</span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(tupA) &lt;&lt; std::endl;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="可变参数模版">可变参数模版</h2>
<p>c++11之前，类模版和函数模版都只能接受固定数目的模版参数。c++11允许，<strong>任意个数、任意类型</strong>的模版参数。</p>
<h3 id="可变参数函数模板">可变参数函数模板</h3>
<p>下列代码声明的函数模版 <code>fun</code>
可以接受任意个数、任意类型的模版参数作为他的模版形参。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Values&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Values... values)</span> </span>{}</span><br></pre></td></tr></tbody></table></figure>
<p>其中 <code>Values</code> 是一个模版参数包， <code>values</code>
是一个函数参数包，表示0个或多个函数参数。函数模版只能含有一个模版参数包，且模版参数包必须位于所有模版参数的最右侧。</p>
<p>所以，可以这么调用 <code>fun</code> 函数：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fun</span>();</span><br><span class="line"><span class="built_in">fun</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">fun</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">fun</span>(<span class="number">1</span>, <span class="number">0.0</span>, <span class="string">"abc"</span>);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="参数包展开">参数包展开</h3>
<p>对于函数模版而言，参数包展开的方式有以下几种：</p>
<ul>
<li>函数参数展开</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(args...); <span class="comment">// expands to f(E1, E2, E3)</span></span><br><span class="line"><span class="built_in">f</span>(&amp;args...); <span class="comment">// expands to f(&amp;E1, &amp;E2, &amp;E3)</span></span><br><span class="line"><span class="built_in">f</span>(n, ++args...); <span class="comment">// expands to f(n, ++E1, ++E2, ++E3);</span></span><br><span class="line"><span class="built_in">f</span>(++args..., n); <span class="comment">// expands to f(++E1, ++E2, ++E3, n);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Ts...)</span> </span>{}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>初始化器展开</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Class <span class="title">c1</span><span class="params">(&amp;args...)</span></span>; <span class="comment">// 调用 Class::Class(&amp;E1, &amp;E2, &amp;E3)</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>模版参数展开</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">A</span>, <span class="keyword">class</span> <span class="title class_">B</span>, <span class="keyword">class</span>... C&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(A arg1, B arg2, C... arg3)</span> </span>{</span><br><span class="line">	<span class="built_in">tuple</span>&lt;A, B, C...&gt;(); <span class="comment">// 展开成 tuple&lt;A, B, E1, E2, E3&gt;()</span></span><br><span class="line">	<span class="built_in">tuple</span>&lt;C..., A, B&gt;(); <span class="comment">// 展开成 tuple&lt;E1, E2, E3, A, B&gt;()</span></span><br><span class="line">	<span class="built_in">tuple</span>&lt;A, C..., B&gt;(); <span class="comment">// 展开成 tuple&lt;A, E1, E2, E3, B&gt;()</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="递归展开">递归展开</h3>
<p>如果需要单独访问参数包中的每个参数，则需要递归的方式展开。</p>
<p>只需要提供展开参数包的递归函数，并提供终止展开的函数重载。</p>
<p>举个例子，下面这个代码段使用了递归函数方式展开参数包，实现了可接受大于等于1个参数的取最大值函数。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归终止函数</span></span><br><span class="line"><span class="comment">// C++20 中，使用 auto 也可以定义模版，即 简写函数模版</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span><span class="params">(<span class="keyword">auto</span> a)</span> </span>{ <span class="keyword">return</span> a; }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明等价于</span></span><br><span class="line"><span class="comment">// template&lt;typename T&gt;</span></span><br><span class="line"><span class="comment">// auto max(T);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开参数包的递归函数</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span><span class="params">(<span class="keyword">auto</span> first, <span class="keyword">auto</span>... rest)</span> </span>{</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> second = <span class="built_in">max</span>(rest...);</span><br><span class="line">	<span class="keyword">return</span> first &gt; second ? first : second;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明等价于</span></span><br><span class="line"><span class="comment">// template&lt;typename First, typename... Rest&gt;</span></span><br><span class="line"><span class="comment">// auto max(First, Rest...);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int b = max(1, "abc"); // 编译不通过，没有 &gt; 操作符能接受 int 和 const char* 类型</span></span><br><span class="line"><span class="type">int</span> c = <span class="built_in">max</span>(<span class="number">1</span>, <span class="number">233</span>); <span class="comment">// 233</span></span><br><span class="line"><span class="type">int</span> d = <span class="built_in">max</span>(<span class="number">1</span>, <span class="number">233</span>, <span class="number">666</span>, <span class="number">10086</span>); <span class="comment">// 10086</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="应用">应用</h3>
<p>在调试的时候有时会倾向于输出中间变量而不是IDE的调试功能。但输出的变量很多时，就要些很多重复代码，这就可以用上可变参数模版和可变参数宏。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Author: Backl1ght, c0nstexpr(Coauthor)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> vector&lt;T&gt;&amp; V) {</span><br><span class="line">	os &lt;&lt; <span class="string">"[ "</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; vv : V) os &lt;&lt; vv &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">	os &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> var_debug {</span><br><span class="line">	<span class="function"><span class="keyword">auto</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* fmt, <span class="type">const</span> <span class="keyword">auto</span>&amp; t)</span> </span>{</span><br><span class="line">		<span class="keyword">for</span> (; *fmt == <span class="string">' '</span>; ++fmt);</span><br><span class="line">		<span class="keyword">for</span> (; *fmt != <span class="string">','</span> &amp;&amp; *fmt != <span class="string">'\0'</span>; ++fmt) cout &lt;&lt; *fmt;</span><br><span class="line">		cout &lt;&lt; <span class="string">'='</span> &lt;&lt; t &lt;&lt; *(fmt++) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">		<span class="keyword">return</span> fmt;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* fmt, <span class="type">const</span> <span class="keyword">auto</span>&amp;... args)</span> </span>{</span><br><span class="line">		((fmt = <span class="built_in">print</span>(fmt, args)), ...); <span class="comment">// c++17 折叠表达式</span></span><br><span class="line">	}</span><br><span class="line">} <span class="comment">// namespace var_debug</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(..) var_debug::print(#__VA_ARGS__, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="type">int</span> a = <span class="number">666</span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">({<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>})</span></span>;</span><br><span class="line">	string c = <span class="string">"hello world"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// before</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"manual count print\n"</span></span><br><span class="line">		 &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">", b="</span> &lt;&lt; b &lt;&lt; <span class="string">", c="</span> &lt;&lt; c</span><br><span class="line">		 &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// a = 666, b = [1, 2, 3, ], c = hello world</span></span><br><span class="line">	<span class="comment">// 如果用 printf 的话，在只有基本数据类型的时候是比较方便的，但是如果要输出 vector 等的内容的话，就会比较麻烦</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// after</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"vararg template print\n"</span>;</span><br><span class="line">	<span class="built_in">debug</span>(a, b, c); <span class="comment">// a=666, b[1, 2, 3, ], c = hello world</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>这样一来，如果事先在代码模板里写好 DEBUG
的相关代码，后续输出中间变量的时候就会方便许多。</p>
<h1 id="lambda-表达式">Lambda 表达式</h1>
<p>下面是 Lambda 表达式的语法：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) <span class="keyword">mutable</span> -&gt; <span class="keyword">return</span>-type {statement}</span><br></pre></td></tr></tbody></table></figure>
<p>下面我们分别对其中的 <code>capture</code>, <code>parameters</code>,
<code>mutable</code>, <code>return-type</code>, <code>statement</code>
进行介绍。</p>
<h2 id="capture捕获字句"><code>capture</code>捕获字句</h2>
<p>Lambda 表达式以 capture
子句开头，它指定哪些变量被捕获，以及捕获是通过值还是引用：有&nbsp;<code>&amp;</code>&nbsp;符号前缀的变量通过引用访问，没有该前缀的变量通过值访问。空的
capture 子句&nbsp;<code>[]</code>&nbsp;指示 Lambda
表达式的主体不访问封闭范围中的变量。</p>
<p>我们也可以使用默认捕获模式：<code>&amp;</code>&nbsp;表示捕获到的所有变量都通过引用访问，<code>=</code>&nbsp;表示捕获到的所有变量都通过值访问。之后我们可以为特定的变量&nbsp;<strong>显式</strong>&nbsp;指定相反的模式。</p>
<p>默认捕获时，会捕获 Lambda 中提及的变量。获的变量成为 Lambda
的一部分；与函数参数相比，调用 Lambda 时不必传递它们。</p>
<p>以下是一些常见的例子</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = []() { <span class="keyword">return</span> a * <span class="number">9</span>; }; <span class="comment">// Error, 无法访问 'a'</span></span><br><span class="line"><span class="keyword">auto</span> f = [a]() { <span class="keyword">return</span> a * <span class="number">9</span>; }; <span class="comment">// OK, 'a' 被值「捕获」</span></span><br><span class="line"><span class="keyword">auto</span> f = [&amp;a]() { <span class="keyword">return</span> a++; }; <span class="comment">// OK, 'a' 被引用「捕获」</span></span><br><span class="line">								 <span class="comment">// 注意：请保证 Lambda 被调用时 a 没有被销毁</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">f</span>();  <span class="comment">// f 从捕获列表里获得a的值，因此无需通过参数传入a</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="parameters-参数列表"><code>parameters</code> 参数列表</h2>
<p>大多数情况下类似于函数的参数列表，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lam = [](<span class="type">int</span> a, <span class="type">int</span> b) { <span class="keyword">return</span> a + b; }</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">lam</span>(<span class="number">1</span>, <span class="number">9</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">lam</span>(<span class="number">2</span>, <span class="number">6</span>) &lt;&lt; std::endl;</span><br></pre></td></tr></tbody></table></figure>
<p>c++14 中，若参数类型是泛型，则可以使用auto声明类型：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lam = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)</span><br></pre></td></tr></tbody></table></figure>
<p>一个例子</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[] = {<span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>};</span><br><span class="line">std::<span class="built_in">sort</span>(x, x + <span class="number">7</span>, [](<span class="type">int</span> a, <span class="type">int</span> b) { <span class="built_in">return</span> (a &gt; b); });</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i: x) std::cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>这将打印出&nbsp;<code>x</code>&nbsp;数组从大到小排序后的结果。</p>
<p>由于&nbsp;<strong>parameters
参数列表</strong>&nbsp;是可选的，如果不将参数传递给 Lambda 表达式，并且其
Lambda 声明器不包含
mutable，且没有后置返回值类型，则可以省略空括号。</p>
<p>Lambda 表达式也可以将另一个 Lambda 表达式作为其参数。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	<span class="comment">// 返回另一个计算两数之和 Lambda 表达式</span></span><br><span class="line">	<span class="keyword">auto</span> addtwointegers = [](<span class="type">int</span> x) -&gt; function&lt;<span class="built_in">int</span>(<span class="type">int</span>)&gt; {</span><br><span class="line">		<span class="keyword">return</span> [=](<span class="type">int</span> y) { <span class="keyword">return</span> x + y; };</span><br><span class="line">	};</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 接受另外一个函数 f 作为参数，返回 f(z) 的两倍</span></span><br><span class="line">	<span class="keyword">auto</span> higherorder = [](<span class="type">const</span> function&lt;<span class="built_in">int</span>(<span class="type">int</span>)&gt;&amp; f, <span class="type">int</span> x) {</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">f</span>(z) * <span class="number">2</span>;</span><br><span class="line">	};</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调用绑定到 higherorder 的 Lambda 表达式</span></span><br><span class="line">	<span class="keyword">auto</span> answer = <span class="built_in">higheroder</span>(<span class="built_in">addtwointegers</span>(<span class="number">7</span>), <span class="number">8</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 答案为 (7 + 8) * 2 = 30</span></span><br><span class="line">	cout &lt;&lt; answer &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="mutable-可变规范"><code>mutable</code> 可变规范</h2>
<p>利用可变规范，Lambda
表达式的主体可以修改通过值捕获的变量。若使用此关键字，则
parameters&nbsp;<strong>不可省略</strong>（即使为空）。</p>
<p>一个例子，使用&nbsp;<strong>capture 捕获字句</strong>&nbsp;中的例子，来观察 a
的值的变化：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> func = [a]() <span class="keyword">mutable</span> { ++a; };</span><br></pre></td></tr></tbody></table></figure>
<p>此时 lambda 中的 a 的值改变为 1，lambda 外的 a 保持不变。</p>
<p><code>return-type</code> 返回类型</p>
<p>用于指定 Lambda
表达式的返回类型。若没有指定返回类型，则返回类型将被自动推断（行为与用&nbsp;<code>auto</code>&nbsp;声明返回值的普通函数一致）。具体的，如果函数体中没有&nbsp;<code>return</code>&nbsp;语句，返回类型将被推导为&nbsp;<code>void</code>，否则根据返回值推导。若有多个&nbsp;<code>return</code>&nbsp;语句且返回值类型不同，将产生编译错误。</p>
<p>例如，上文的&nbsp;<code>lam</code>&nbsp;也可以写作：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lam = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span></span><br></pre></td></tr></tbody></table></figure>
<p>再举两个例子：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = [](<span class="type">int</span> i) { <span class="keyword">return</span> i; }; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">auto</span> x2 = [] { <span class="keyword">return</span> {<span class="number">1</span>, <span class="number">2</span>}; }; <span class="comment">// Error, 返回类型被推导为 void</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="statement-lambda-主体"><code>statement Lambda</code> 主体</h2>
<p>Lambda 主体可包含任何函数可包含的部分。普通函数和 Lambda
表达式主体均可访问以下变量类型：</p>
<ul>
<li><p>从封闭范围捕获变量</p></li>
<li><p>参数</p></li>
<li><p>本地声明的变量</p></li>
<li><p>在一个 <code>class</code> 中声明时，若捕获 <code>this</code>,
则可以访问该对象的成员</p></li>
<li><p>具有静态存储时间的任何变量，如全局变量</p></li>
</ul>
<p>下面是一个例子</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="type">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">	[&amp;, n](<span class="type">int</span> a) <span class="keyword">mutable</span> { m = (++n) + a; }(<span class="number">4</span>);</span><br><span class="line">	std::cout &lt;&lt; m &lt;&lt; <span class="string">" "</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>最后我们得到输出&nbsp;<code>5 0</code>。这是由于&nbsp;<code>n</code>&nbsp;是通过值捕获的，在调用
Lambda
表达式后仍保持原来的值&nbsp;<code>0</code>&nbsp;不变。<code>mutable</code>&nbsp;规范允许&nbsp;<code>n</code>&nbsp;在
Lambda 主体中被修改，将&nbsp;<code>mutable</code>&nbsp;删去则编译不通过。</p>

                    
                </div>

                
                        
<div class="post-copyright-info-container border-box">
    <div class="copyright-info-content border-box">
        <div class="copyright-info-top border-box">
            <div class="copyright-post-title border-box text-ellipsis">
                C++进阶
            </div>

            <div class="copyright-post-link border-box text-ellipsis">
                2024/11/20/others-oi-wiki-C-进阶/
            </div>
        </div>

        <div class="copyright-info-bottom border-box">
            <div class="copyright-post-author bottom-item">
                <div class="type">
                    Author
                </div>
                <div class="content">amor mío de mi vida</div>
            </div>

            <div class="post-time bottom-item">
                <div class="type">
                    Published
                </div>
                <div class="content">2024-11-20 18:13</div>
            </div>


            <div class="post-license bottom-item">
                <div class="type">
                    License
                </div>
                <div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0">
                    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed" target="_blank">
                        
                            <i class="fa-brands fa-creative-commons"></i>
                            <i class="fa-brands fa-creative-commons-by"></i>
                            <i class="fa-brands fa-creative-commons-nc"></i>
                            <i class="fa-brands fa-creative-commons-sa"></i>
                        
                    </a>
                </div>
            </div>
        </div>

        <i class="copyright-bg fa-solid fa-copyright"></i>
    </div>
    <div class="copy-copyright-info flex-center tooltip" data-tooltip-content="Copy copyright info" data-tooltip-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/cpp/">cpp</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                            <div class="post-share-container border-box">
    <ul class="share-list-wrap border-box">
        <li class="qq share-item border-box flex-center tooltip" data-tooltip-content="Share to QQ">
            <i class="fa-brands fa-qq"></i>
        </li>
        <li class="wechat share-item border-box flex-center tooltip tooltip-img" data-tooltip-content="Share to WeChat" data-tooltip-img-tip="Scan by WeChat" data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;">
            <i class="fa-brands fa-weixin"></i>
        </li>
        <li class="weibo share-item border-box flex-center tooltip" data-tooltip-content="Share to WeiBo">
            <i class="fa-brands fa-weibo"></i>
        </li>
    </ul>
</div>

                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev" rel="prev" href="/2024/11/20/others-Design-Patterns/" title="Welcome to use Hexo Theme Keep">
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">Welcome to use Hexo Theme Keep</span>
                                        <span class="post-nav-item">Prev posts</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next" rel="next" href="/2024/11/20/course-CS267-10-Advanced-MPI-and-Collective-Communication-Algorithms/" title="Advanced MPI and Collective Communication Algorithms">
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">Advanced MPI and Collective Communication Algorithms</span>
                                        <span class="post-nav-item">Next posts</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%88%AB"><span class="nav-text">值类别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-text">不必要的复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%80%BC%E7%B1%BB%E5%88%AB"><span class="nav-text">C语言中的值类别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c98%E4%B8%AD%E7%9A%84%E5%80%BC%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="nav-text">C++98中的值的类别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4"><span class="nav-text">复制消除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c11-%E4%B8%AD%E5%80%BC%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="nav-text">C++11 中值的类别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stdmove"><span class="nav-text">std::move</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c17-%E4%B8%AD%E7%9A%84%E5%80%BC%E7%B1%BB%E5%88%AB"><span class="nav-text">C++17 中的值类别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA"><span class="nav-text">常见误区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">重载运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E5%88%B6"><span class="nav-text">限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">基本算数运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">自增自减运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">函数调用运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">比较运算符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-text">引用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8-t"><span class="nav-text">左值引用 T&amp;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-t-c-11"><span class="nav-text">右值引用 T&amp;&amp; C++ 11</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8"><span class="nav-text">悬垂引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7"><span class="nav-text">引用相关的优化技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E9%99%A4%E9%9D%9E%E8%BD%BB%E9%87%8F%E5%AF%B9%E8%B1%A1%E5%85%A5%E5%8F%82%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%BC%80%E9%94%80"><span class="nav-text">消除非轻量对象入参的拷贝开销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E5%B7%A6%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%B3%E5%80%BC"><span class="nav-text">将左值转换为右值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-text">常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="nav-text">const 类型限定符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F-1"><span class="nav-text">常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="nav-text">常量引用、常量指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">const 成员函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F-constexpr"><span class="nav-text">常量表达式 constexpr</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B0%E7%89%88%E7%9A%84-c-%E7%89%B9%E6%80%A7"><span class="nav-text">新版的 C++ 特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#auto-%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="nav-text">auto 类型说明符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84-for-%E5%BE%AA%E7%8E%AF"><span class="nav-text">基于范围的 for 循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#range_declaration-%E8%8C%83%E5%9B%B4%E5%A3%B0%E6%98%8E"><span class="nav-text">range_declaration 范围声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#range_expression-%E8%8C%83%E5%9B%B4%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">range_expression 范围表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#loop_statement-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="nav-text">loop_statement 循环语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5c20"><span class="nav-text">初始化语句（C++20）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-text">函数对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E5%BA%93c20"><span class="nav-text">范围库（C++20）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#view-%E8%A7%86%E5%9B%BE"><span class="nav-text">View 视图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constrained-algorithm-%E5%8F%97%E7%BA%A6%E6%9D%9F%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-text">Constrained Algorithm
受约束的算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#decltype-%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="nav-text">decltype 说明符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stdfunction"><span class="nav-text">std::function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stdtuple-%E5%85%83%E7%BB%84"><span class="nav-text">std::tuple 元组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E7%89%88"><span class="nav-text">可变参数模版</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-text">可变参数函数模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%8C%85%E5%B1%95%E5%BC%80"><span class="nav-text">参数包展开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%B1%95%E5%BC%80"><span class="nav-text">递归展开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-text">应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">Lambda 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#capture%E6%8D%95%E8%8E%B7%E5%AD%97%E5%8F%A5"><span class="nav-text">capture捕获字句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#parameters-%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="nav-text">parameters 参数列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mutable-%E5%8F%AF%E5%8F%98%E8%A7%84%E8%8C%83"><span class="nav-text">mutable 可变规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#statement-lambda-%E4%B8%BB%E4%BD%93"><span class="nav-text">statement Lambda 主体</span></a></li></ol></li>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
        ©&nbsp;<span>2020</span>&nbsp;-&nbsp;2024
        
            &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">amor mío de mi vida</a>
        
    </div>

    <div class="theme-info info-item">
        Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;&amp;&nbsp;Theme&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div>

    

    
        <div class="count-info info-item">
            

            
                <span class="count-item border-box uv">
                    <span class="item-type border-box">Unique Visitor</span>
                    <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span>
                </span>
            

            
                <span class="count-item border-box pv">
                    <span class="item-type border-box">Page View</span>
                    <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span>
                </span>
            
        </div>
    

    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <!-- toggle mode -->
        
            <li class="tools-item tool-toggle-theme-mode flex-center">
                <i class="fas fa-moon"></i>
            </li>
        

        <!-- rss -->
        

        <!-- to bottom -->
        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%88%AB"><span class="nav-text">值类别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-text">不必要的复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%80%BC%E7%B1%BB%E5%88%AB"><span class="nav-text">C语言中的值类别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c98%E4%B8%AD%E7%9A%84%E5%80%BC%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="nav-text">C++98中的值的类别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4"><span class="nav-text">复制消除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c11-%E4%B8%AD%E5%80%BC%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="nav-text">C++11 中值的类别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stdmove"><span class="nav-text">std::move</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c17-%E4%B8%AD%E7%9A%84%E5%80%BC%E7%B1%BB%E5%88%AB"><span class="nav-text">C++17 中的值类别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA"><span class="nav-text">常见误区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">重载运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E5%88%B6"><span class="nav-text">限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">基本算数运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">自增自减运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">函数调用运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">比较运算符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-text">引用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8-t"><span class="nav-text">左值引用 T&amp;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-t-c-11"><span class="nav-text">右值引用 T&amp;&amp; C++ 11</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8"><span class="nav-text">悬垂引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7"><span class="nav-text">引用相关的优化技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E9%99%A4%E9%9D%9E%E8%BD%BB%E9%87%8F%E5%AF%B9%E8%B1%A1%E5%85%A5%E5%8F%82%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%BC%80%E9%94%80"><span class="nav-text">消除非轻量对象入参的拷贝开销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E5%B7%A6%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%B3%E5%80%BC"><span class="nav-text">将左值转换为右值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-text">常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="nav-text">const 类型限定符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F-1"><span class="nav-text">常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="nav-text">常量引用、常量指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">const 成员函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F-constexpr"><span class="nav-text">常量表达式 constexpr</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B0%E7%89%88%E7%9A%84-c-%E7%89%B9%E6%80%A7"><span class="nav-text">新版的 C++ 特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#auto-%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="nav-text">auto 类型说明符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84-for-%E5%BE%AA%E7%8E%AF"><span class="nav-text">基于范围的 for 循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#range_declaration-%E8%8C%83%E5%9B%B4%E5%A3%B0%E6%98%8E"><span class="nav-text">range_declaration 范围声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#range_expression-%E8%8C%83%E5%9B%B4%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">range_expression 范围表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#loop_statement-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="nav-text">loop_statement 循环语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5c20"><span class="nav-text">初始化语句（C++20）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-text">函数对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E5%BA%93c20"><span class="nav-text">范围库（C++20）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#view-%E8%A7%86%E5%9B%BE"><span class="nav-text">View 视图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constrained-algorithm-%E5%8F%97%E7%BA%A6%E6%9D%9F%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-text">Constrained Algorithm
受约束的算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#decltype-%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="nav-text">decltype 说明符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stdfunction"><span class="nav-text">std::function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stdtuple-%E5%85%83%E7%BB%84"><span class="nav-text">std::tuple 元组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E7%89%88"><span class="nav-text">可变参数模版</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-text">可变参数函数模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%8C%85%E5%B1%95%E5%BC%80"><span class="nav-text">参数包展开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%B1%95%E5%BC%80"><span class="nav-text">递归展开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-text">应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">Lambda 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#capture%E6%8D%95%E8%8E%B7%E5%AD%97%E5%8F%A5"><span class="nav-text">capture捕获字句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#parameters-%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="nav-text">parameters 参数列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mutable-%E5%8F%AF%E5%8F%98%E8%A7%84%E8%8C%83"><span class="nav-text">mutable 可变规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#statement-lambda-%E4%B8%BB%E4%BD%93"><span class="nav-text">statement Lambda 主体</span></a></li></ol></li>
    </div>
</div>

            </div>
        </div>
    
</main>





<!-- common js -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local search -->

    
<script src="/js/local-search.js"></script>



<!-- lazyload -->

    
<script src="/js/lazyload.js"></script>



<div class="pjax">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        
            
<script src="/js/post/toc.js"></script>

        

        <!-- copyright-info -->
        
            
<script src="/js/post/copyright-info.js"></script>

        

        <!-- share -->
        
            
<script src="/js/post/share.js"></script>

        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->

    
<script src="//cdn.jsdelivr.net/npm/mermaid@10.5.0/dist/mermaid.min.js"></script>

    <script data-pjax="">
      if (window.mermaid) {
        mermaid.init()
      }
    </script>






<!-- pjax -->

    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart()
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd()
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'))
            KEEP.initExecute()
        });
    });
</script>






<script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>