<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-02T08:38:00.752Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Gradle Basics</title>
    <link href="http://example.com/2024/10/02/tools/Gradle/Gradle%20Basics/"/>
    <id>http://example.com/2024/10/02/tools/Gradle/Gradle%20Basics/</id>
    <published>2024-10-02T07:32:31.404Z</published>
    <updated>2024-10-02T08:38:00.752Z</updated>
    
    <content type="html"><![CDATA[<p>Gradle <strong>automates building, testing, and deployment of software</strong> from information in <strong>build scripts</strong>.<br>![[Pasted image 20241002153334.png]]</p><h2 id="Gradle-Project-structure"><a href="#Gradle-Project-structure" class="headerlink" title="Gradle Project structure"></a>Gradle Project structure</h2><p>A Gradle project will look similar to the following:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">├── gradle                             (1)        </span><br><span class="line">│   ├── libs.versions.toml             (2)</span><br><span class="line">│   └── wrapper</span><br><span class="line">│       ├── gradle-wrapper.jar</span><br><span class="line">│       └── gradle-wrapper.properties</span><br><span class="line">├── gradlew                            (3)</span><br><span class="line">├── gradlew.bat                        (3) </span><br><span class="line">├── settings.gradle(.kts)              (4) </span><br><span class="line">├── subproject-a                   </span><br><span class="line">│   ├── build.gradle(.kts)             (5)     </span><br><span class="line">│   └── src                            (6) </span><br><span class="line">└── subproject-b                        </span><br><span class="line">    ├── build.gradle(.kts)             (5) </span><br><span class="line">    └── src                            (6) </span><br></pre></td></tr></table></figure><p>(1)  Gradle directory to store wrapper files and more<br>(2) Gradle version catalog for dependency management<br>(3) Gradle wrapper scripts<br>(4) Gradle settings file to define a root project name and subprojects<br>(5) Gradle build scripts of the two subprojects - <code>subproject-a</code> and <code>subproject-b</code><br>(6) Source code and&#x2F;or additional files for the projects</p><p>Gradle Wrapper<br>The Wrapper is a script that invokes a declared version of Gradle and is <strong>the recommended way to execute a Gradle build</strong>. It is found in the project root directory as a <code>gradlew</code> or <code>gradlew.bat</code> file:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gradlew build     // Linux or OSX</span><br><span class="line">gradlew.bat build  // Windows</span><br></pre></td></tr></table></figure><h2 id="Gradle-Wrapper-Basics"><a href="#Gradle-Wrapper-Basics" class="headerlink" title="Gradle Wrapper Basics"></a>Gradle Wrapper Basics</h2><p>The <strong>recommended way to execute any Gradle build</strong> is with the Gradle Wrapper.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── gradle </span><br><span class="line">│   └── wrapper</span><br><span class="line">│       ├── gradle-wrapper.jar         (1)</span><br><span class="line">│       └── gradle-wrapper.properties  (2)</span><br><span class="line">├── gradlew  (3)</span><br><span class="line">└── gradlew.bat (4)</span><br></pre></td></tr></table></figure><p>(1) <code>gradle-wrapper.jar</code>: This is a small JAR file that contains the Gradle Wrapper code. It is responsible for downloading and installing the correct version of Gradle for a project if it’s not already installed.<br>(2) <code>gradle-wrapper.properties</code>: This file contains configuration properties for the Gradle Wrapper, such as the distribution URL (where to download Gradle from) and the distribution type (ZIP or TARBALL).<br>(3) <code>gradlew</code>: This is a shell script (Unix-based systems) that acts as a wrapper around <code>gradle-wrapper.jar</code>. It is used to execute Gradle tasks on Unix-based systems without needing to manually install Gradle.<br>(4) <code>gradlew.bat</code>: This is a batch script (Windows) that serves the same purpose as <code>gradlew</code> but is used on Windows systems.</p><p>If you want to view or update the Gradle version of your project, use the command line. Do not edit the wrapper files manually:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./gradlew --version</span><br><span class="line">./gradlew wrapper --gradle-version 7.2</span><br></pre></td></tr></table></figure><h2 id="Command-Line-Interface-Basics"><a href="#Command-Line-Interface-Basics" class="headerlink" title="Command-Line Interface Basics"></a>Command-Line Interface Basics</h2><p>Substitute <code>./gradlew</code> (in macOS &#x2F; Linux) or <code>gradlew.bat</code> (in Windows) for <code>gradle</code> in the following examples.</p><p>Executing Gradle on the command line conforms to the following structure:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle [taskName...] [--option-name...]</span><br></pre></td></tr></table></figure><p>Options are allowed <em>before</em> and <em>after</em> task names.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle [--option-name...] [taskName...]</span><br></pre></td></tr></table></figure><p>If multiple tasks are specified, you should separate them with a space.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle [taskName1 taskName2...] [--option-name...]</span><br></pre></td></tr></table></figure><p>Options that accept values can be specified with or without <code>=</code> between the option and argument. The use of <code>=</code> is recommended.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle [...] --console=plain</span><br></pre></td></tr></table></figure><p>Options that enable behavior have long-form options with inverses specified with <code>--no-</code>. The following are opposites.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gradle [...] --build-cache</span><br><span class="line">gradle [...] --no-build-cache</span><br></pre></td></tr></table></figure><p>Many long-form options have short-option equivalents. The following are equivalent:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gradle --<span class="built_in">help</span></span><br><span class="line">gradle -h</span><br></pre></td></tr></table></figure><p>To execute a task called <code>taskName</code> on the root project, type:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle :taskName</span><br></pre></td></tr></table></figure><p>To pass an option to a task, prefix the option name with <code>--</code> after the task name:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle taskName --exampleOption=exampleValue</span><br></pre></td></tr></table></figure><h2 id="Settings-File-Basics"><a href="#Settings-File-Basics" class="headerlink" title="Settings File Basics"></a>Settings File Basics</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rootProject.name = <span class="string">&#x27;root-project&#x27;</span>   (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;sub-project-a&#x27;</span>)            (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;sub-project-b&#x27;</span>)</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;sub-project-c&#x27;</span>)</span><br></pre></td></tr></table></figure><p>(1) Define the project name<br>(2) Add subprojects</p><h2 id="Build-file-Basics"><a href="#Build-file-Basics" class="headerlink" title="Build file Basics"></a>Build file Basics</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;application&#x27;</span>                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">application &#123;</span><br><span class="line">    mainClass = <span class="string">&#x27;com.example.Main&#x27;</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1) Add plugins<br>    Plugins extend Gradle’s functionality and can contribute tasks to a project.<br>(2) Use convention properties<br>    A plugin adds tasks to a project. It also adds properties and methods to a project.The <code>application</code> plugin defines tasks that package and distribute an application, such as the <code>run</code> task.</p><h2 id="Dependency-Management-Basics"><a href="#Dependency-Management-Basics" class="headerlink" title="Dependency Management Basics"></a>Dependency Management Basics</h2><p>To add a dependency to your project, specify a dependency in the dependencies block of your <code>build.gradle(.kts)</code> file.<br>Dependencies in Gradle are grouped by <strong>configurations</strong>.<br>You can view your dependency tree in the terminal using the following command</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew :app:dependencies</span><br></pre></td></tr></table></figure><h2 id="Task-Basics"><a href="#Task-Basics" class="headerlink" title="Task Basics"></a>Task Basics</h2><p>A task represents some <strong>independent unit of work</strong> that a build performs, such as compiling classes, creating a JAR, generating Javadoc, or publishing archives to a repository.<br>You run a Gradle <code>build</code> task using the <code>gradle</code> command or by invoking the Gradle Wrapper (<code>./gradlew</code> or <code>gradlew.bat</code>) in your project directory:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure><p>You can list all the available tasks in the project by running the following command in the terminal:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew tasks</span><br></pre></td></tr></table></figure><p>Many times, a task requires another task to run first. Build scripts can optionally define task dependencies. Gradle then automatically determines the task execution order.</p><h2 id="Plugin-Basics"><a href="#Plugin-Basics" class="headerlink" title="Plugin Basics"></a>Plugin Basics</h2><p>Gradle is built on a plugin system. Gradle itself is primarily composed of infrastructure, such as a sophisticated dependency resolution engine. The rest of its functionality comes from plugins. A plugin is a piece of software that <strong>provides additional functionality to the Gradle build system</strong>.</p><p>Plugins can be applied to a Gradle build script to <strong>add new tasks, configurations, or other build-related capabilities</strong>:</p><ul><li>Core plugins<br>  Gradle Core plugins are a set of plugins that are included in the Gradle distribution itself. These plugins provide essential functionality for building and managing projects.<br>  There are many <a class="link"   href="https://docs.gradle.org/current/userguide/plugin_reference.html#plugin_reference" >Gradle Core Plugins<i class="fas fa-external-link-alt"></i></a> users can take advantage of.</li><li>Community plugins<br>  Community plugins are plugins developed by the Gradle community, rather than being part of the core Gradle distribution. These plugins provide additional functionality that may be specific to certain use cases or technologies.<br>  Community plugins can be published at the <a class="link"   href="http://plugins.gradle.org/" >Gradle Plugin Portal<i class="fas fa-external-link-alt"></i></a>, where other Gradle users can easily discover and use them.</li><li>Local plugins<br>  Custom or local plugins are developed and used within a specific project or organization. These plugins are not shared publicly and are tailored to the specific needs of the project or organization.</li></ul><h2 id="Incremental-Builds-and-Build-Caching"><a href="#Incremental-Builds-and-Build-Caching" class="headerlink" title="Incremental Builds and Build Caching"></a>Incremental Builds and Build Caching</h2><p>Incremental builds are always enabled, and the best way to see them in action is to turn on <em>verbose mode</em>. With verbose mode, each task state is labeled during a build:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew compileJava --console=verbose</span><br></pre></td></tr></table></figure><p>The build cache stores previous build results and restores them when needed. It prevents the redundant work and cost of executing time-consuming and expensive processes.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew compileJava --build-cache</span><br></pre></td></tr></table></figure><h2 id="Build-Scan"><a href="#Build-Scan" class="headerlink" title="Build Scan"></a>Build Scan</h2><p>To enable build scans on a gradle command, add <code>--scan</code> to the command line option:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build --scan</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a class="link"   href="https://docs.gradle.org/current/userguide/gradle_wrapper.html#gradle_wrapper_reference" >Gradle Wrapper reference<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://docs.gradle.org/current/userguide/command_line_interface.html#command_line_interface" >Gradle Command Line Interface reference<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://docs.gradle.org/current/userguide/writing_settings_files.html#writing_settings_files" >Writing Settings File<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://docs.gradle.org/current/userguide/writing_build_scripts.html#writing_build_scripts" >Writing Build Scripts<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://docs.gradle.org/current/userguide/glossary.html#dependency_management_terminology" >Dependency Management chapter<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://docs.gradle.org/current/userguide/custom_plugins.html#custom_plugins" >Plugin development chapter<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://docs.gradle.org/current/userguide/build_cache.html#build_cache" >Build cache chapter<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Gradle &lt;strong&gt;automates building, testing, and deployment of software&lt;/strong&gt; from information in &lt;strong&gt;build scripts&lt;/strong&gt;.&lt;br&gt;![</summary>
      
    
    
    
    <category term="Gradle" scheme="http://example.com/categories/Gradle/"/>
    
    
    <category term="tools" scheme="http://example.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>RARS</title>
    <link href="http://example.com/2024/10/02/riscv/RARS/"/>
    <id>http://example.com/2024/10/02/riscv/RARS/</id>
    <published>2024-10-02T06:59:29.608Z</published>
    <updated>2024-10-02T07:04:02.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Command-Line-Tool"><a href="#Command-Line-Tool" class="headerlink" title="Command Line Tool"></a>Command Line Tool</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a -- assemble only, do not simulate</span><br><span class="line">ae&lt;n&gt; -- terminate RARS with integer exit code &lt;n&gt; if an assemble error occurs.</span><br><span class="line">ascii -- display memory or register contents interpreted as ASCII codes.</span><br><span class="line">b -- brief - do not display/memory address along with contents.</span><br><span class="line">d -- display RARS debugging statements</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Command-Line-Tool&quot;&gt;&lt;a href=&quot;#Command-Line-Tool&quot; class=&quot;headerlink&quot; title=&quot;Command Line Tool&quot;&gt;&lt;/a&gt;Command Line Tool&lt;/h2&gt;&lt;figure class</summary>
      
    
    
    
    <category term="Hexo" scheme="http://example.com/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
    <category term="Keep" scheme="http://example.com/tags/Keep/"/>
    
  </entry>
  
  <entry>
    <title>Welcome to use Hexo Theme Keep</title>
    <link href="http://example.com/2024/10/01/riscv/DrMIPS/"/>
    <id>http://example.com/2024/10/01/riscv/DrMIPS/</id>
    <published>2024-10-01T12:41:27.328Z</published>
    <updated>2024-10-01T12:44:29.350Z</updated>
    
    
    
    
    <category term="Hexo" scheme="http://example.com/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
    <category term="Keep" scheme="http://example.com/tags/Keep/"/>
    
  </entry>
  
  <entry>
    <title>CMake Cookbook Chapter 1</title>
    <link href="http://example.com/2024/10/01/tools/CMake%20Cookbook/CMake%20Cookbook%20Chapter%201/"/>
    <id>http://example.com/2024/10/01/tools/CMake%20Cookbook/CMake%20Cookbook%20Chapter%201/</id>
    <published>2024-10-01T08:15:41.477Z</published>
    <updated>2024-10-02T08:38:32.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="将单个源文件编译为可执行文件"><a href="#将单个源文件编译为可执行文件" class="headerlink" title="将单个源文件编译为可执行文件"></a>将单个源文件编译为可执行文件</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>标准构建命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -H. -Bbuild</span><br></pre></td></tr></table></figure><p>该命令是跨平台的，使用了<code>-H</code>和<code>-B</code>为CLI选项。<code>-H</code>表示当前目录中搜索根<code>CMakeLists.txt</code>文件。<code>-Bbuild</code>告诉CMake在一个名为<code>build</code>的目录中生成所有的文件。</p><p>GNU&#x2F;Linux上，CMake默认生成Unix Makefile来构建项目：</p><ul><li><code>Makefile</code>: <code>make</code>将运行指令来构建项目。</li><li><code>CMakefile</code>：包含临时文件的目录，CMake用于检测操作系统、编译器等。此外，根据所选的生成器，它还包含特定的文件。</li><li><code>cmake_install.cmake</code>：处理安装规则的CMake脚本，在项目安装时使用。</li><li><code>CMakeCache.txt</code>：如文件名所示，CMake缓存。CMake在重新运行配置时使用这个文件。</li></ul><h3 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h3><p>官方文档 <a class="link"   href="https://cmake.org/runningcmake/" >https://cmake.org/runningcmake/<i class="fas fa-external-link-alt"></i></a> 给出了运行CMake的简要概述。由CMake生成的构建系统，即上面给出的示例中的Makefile，将包含为给定项目构建目标文件、可执行文件和库的目标及规则。<code>hello-world</code>可执行文件是在当前示例中的唯一目标，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target <span class="built_in">help</span></span><br><span class="line">The following are some of the valid targets <span class="keyword">for</span> this Makefile:</span><br><span class="line">... all (the default <span class="keyword">if</span> no target is provided)</span><br><span class="line">... clean</span><br><span class="line">... depend</span><br><span class="line">... rebuild_cache</span><br><span class="line">... hello-world</span><br><span class="line">... edit_cache</span><br><span class="line">... hello-world.o</span><br><span class="line">... hello-world.i</span><br><span class="line">... hello-world.s</span><br></pre></td></tr></table></figure><p>CMake生成的目标比构建可执行文件的目标要多。可以使用<code>cmake --build . --target &lt;target-name&gt;</code>语法，实现如下功能：</p><ul><li><strong>all</strong>(或Visual Studio generator中的ALL_BUILD)是默认目标，将在项目中构建所有目标。</li><li><strong>clean</strong>，删除所有生成的文件。</li><li><strong>rebuild_cache</strong>，将调用CMake为源文件生成依赖(如果有的话)。</li><li><strong>edit_cache</strong>，这个目标允许直接编辑缓存。</li></ul><p>对于更复杂的项目，通过测试阶段和安装规则，CMake将生成额外的目标：</p><ul><li><strong>test</strong>(或Visual Studio generator中的<strong>RUN_TESTS</strong>)将在CTest的帮助下运行测试套件。我们将在第4章中详细讨论测试和CTest。</li><li><strong>install</strong>，将执行项目安装规则。我们将在第10章中讨论安装规则。</li><li><strong>package</strong>，此目标将调用CPack为项目生成可分发的包。打包和CPack将在第11章中讨论。</li></ul><h2 id="切换生成器"><a href="#切换生成器" class="headerlink" title="切换生成器"></a>切换生成器</h2><p>使用一下命令在平台上找到生成器名单，以及安装的CMake版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>显式的使用<code>-G</code>切换生成器</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p build </span><br><span class="line">cd build </span><br><span class="line">cmake -G Ninja ..</span><br></pre></td></tr></table></figure><p>构建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build .</span><br></pre></td></tr></table></figure><p>与前一个配置相比，每一步的输出没什么变化。每个生成器都有自己的文件集，所以编译步骤的输出和构建目录的内容是不同的：</p><ul><li><code>build.ninja</code>和<code>rules.ninja</code>：包含Ninja的所有的构建语句和构建规则。</li><li><code>CMakeCache.txt</code>：CMake会在这个文件中进行缓存，与生成器无关。</li><li><code>CMakeFiles</code>：包含由CMake在配置期间生成的临时文件。</li><li><code>cmake_install.cmake</code>：CMake脚本处理安装规则，并在安装时使用。</li></ul><p><code>cmake --build .</code>将<code>ninja</code>命令封装在一个跨平台的接口中。</p><h2 id="构建和链接静态库和动态库"><a href="#构建和链接静态库和动态库" class="headerlink" title="构建和链接静态库和动态库"></a>构建和链接静态库和动态库</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">01</span> LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span></span><br><span class="line">STATIC</span><br><span class="line"><span class="keyword">Message</span>.hpp</span><br><span class="line"><span class="keyword">Message</span>.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(hello-world hello-world.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello-world <span class="keyword">message</span>)</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><code>add_library(message STATIC Message.hpp Message.cpp)</code>：生成必要的构建指令，将指定的源码编译到库中。<code>add_library</code>的第一个参数是目标名。整个<code>CMakeLists.txt</code>中，可使用相同的名称来引用库。生成的库的实际名称将由CMake通过在前面添加前缀<code>lib</code>和适当的扩展名作为后缀来形成。生成库是根据第二个参数(<code>STATIC</code>或<code>SHARED</code>)和操作系统确定的。</li><li><code>target_link_libraries(hello-world message)</code>: 将库链接到可执行文件。此命令还确保<code>hello-world</code>可执行文件可以正确地依赖于消息库。因此，在消息库链接到<code>hello-world</code>可执行文件之前，需要完成消息库的构建。<br>编译成功后，构建目录包含<code>libmessage.a</code>一个静态库(在GNU&#x2F;Linux上)和<code>hello-world</code>可执行文件。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;将单个源文件编译为可执行文件&quot;&gt;&lt;a href=&quot;#将单个源文件编译为可执行文件&quot; class=&quot;headerlink&quot; title=&quot;将单个源文件编译为可执行文件&quot;&gt;&lt;/a&gt;将单个源文件编译为可执行文件&lt;/h2&gt;&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准</summary>
      
    
    
    
    <category term="CMakeCookbook" scheme="http://example.com/categories/CMakeCookbook/"/>
    
    
    <category term="tools" scheme="http://example.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>CMake Cookbook Inrto</title>
    <link href="http://example.com/2024/10/01/tools/CMake%20Cookbook/CMake%20Cookbook%20Inrto/"/>
    <id>http://example.com/2024/10/01/tools/CMake%20Cookbook/CMake%20Cookbook%20Inrto/</id>
    <published>2024-10-01T06:28:26.185Z</published>
    <updated>2024-10-02T08:38:21.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CMake是一个构建生成器，提供了强大的领域特定语言(DSL)来描述构建系统应该实现的功能。这是CMake的主要优势之一，它允许使用相同的CMake脚本集生成平台原生构建系统。CMake软件工具集，使开发人员可以完全控制给定项目的生命周期：</p><ul><li><strong>CMake</strong>是描述如何在所有主要硬件和操作系统上配置、构建和安装项目，无论是构建可执行文件、库，还是两者都要构建。</li><li><strong>CTest</strong>定义测试、测试套件，并设置应该如何执行。</li><li><strong>CPack</strong>为打包需求提供了DSL。</li><li><strong>CDash</strong>将项目的测试结果在面板中展示。</li></ul><h2 id="覆盖内容"><a href="#覆盖内容" class="headerlink" title="覆盖内容"></a>覆盖内容</h2><p>我们将讨论以下内容：</p><ul><li>使用CMake配置、构建、测试和安装代码项目</li><li>检测用于条件编译的操作系统、处理器、库、文件和程序</li><li>提高代码的可移植性</li><li>CMake帮助下，将大型代码库重构为模块</li><li>构建多语言项目</li><li>知道如何调整他人编写的CMake配置文件</li><li>打包项目进行发布</li><li>将项目迁移为CMake构建</li></ul><p>CMake管理的项目的工作流发生在许多阶段(time)，我们称之为<em>时序</em>。可以简洁地总结如下图：</p><p><img                         lazyload                       alt="image"                       data-src="/images/Pasted%20image%2020241001143329.png"                        alt="cmake时序"                 ></p><ul><li><strong>CMake time</strong>或<strong>configure time</strong>，是CMake运行时的情况。这个阶段中，CMake将处理项目中的CMakeLists.txt文件并配置它。</li><li><strong>Generation time</strong>配置成功后，CMake将生成本地构建工具所需的脚本，以执行项目中的后续步骤。</li><li><strong>Build time</strong>这是在平台和工具原生构建脚本上调用原生构建工具的时候，这些脚本以前是由CMake生成的。此时，将调用编译器，并在特定的构建目录中构建目标(可执行文件和库)。注意递归的CMake time箭头：这看起来令人困惑，但是我们将在本书中多次使用它，用来实现平台无关的构建。</li><li><strong>CTest time</strong>或 <strong>test time</strong>，运行项目的测试套件，以检查目标是否按预期执行。</li><li><strong>CDash time</strong>或<strong>report time</strong>，将测试结果上传到面板，与其他开发人员共享。</li><li><strong>Install time</strong>，将项目的目标、源文件、可执行文件和库从构建目录安装到安装位置。</li><li><strong>CPack time</strong>或<strong>packaging time</strong>，将项目打包以便发布，可以是源代码，也可以是二进制代码。</li><li><strong>Package install time</strong>，在系统范围内安装新生成的包。</li></ul><h2 id="路线图"><a href="#路线图" class="headerlink" title="路线图"></a>路线图</h2><p>第1章，从简单的可执行文件到库，如何配置和使用CMake构建简单的可执行文件和库。</p><p>第2章，检测环境，如何使用简单的CMake命令与操作系统和处理器体系结构交互。</p><p>第3章，检测外部库和程序，如何简化对项目依赖项的检测。</p><p>第4章，创建和运行测试，解释如何利用CMake和CTest的功能来定义和运行测试。</p><p>第5章，配置时操作和构建时操作，如何使用CMake在构建过程的不同阶段执行定制化操作。</p><p>第6章，生成源码，CMake命令可自动生成源码。</p><p>第7章，结构化项目，用于组织您的项目，使它们更易于维护。</p><p>第8章，超级构建，解释了CMake超级构建模式，用于管理关键项目的依赖关系。</p><p>第9章，混合语言项目，构建不同编程语言混合的项目。</p><p>第10章，编写一个安装程序，使用CMake安装项目。</p><p>第11章，打包项目，如何使用CPack生成源文件，并将源文件打包，以及构建用于发布的Python和Conda包。</p><p>第12章，生成文档，如何使用CMake也生成代码的文档。</p><p>第13章，选择生成器和交叉编译，如何使用CMake交叉编译项目。</p><p>第14章，测试面板，如何将测试结果报告到在面板上。</p><p>第15章，将项目移植到CMake中，将展示实践示例、注意事项和一些技巧，这些将帮助您将项目移植到基于CMake的构建系统中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;CMake是一个构建生成器，提供了强大的领域特定语言(DSL)来描述构建系统应该实现的功能。这是CMake的主要优势之一，它允许使用相同的C</summary>
      
    
    
    
    <category term="CMakeCookbook" scheme="http://example.com/categories/CMakeCookbook/"/>
    
    
    <category term="tools" scheme="http://example.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>The Pragmatic Programmer</title>
    <link href="http://example.com/2024/09/27/book/The%20Pragmatic%20Programmer/"/>
    <id>http://example.com/2024/09/27/book/The%20Pragmatic%20Programmer/</id>
    <published>2024-09-27T15:04:41.139Z</published>
    <updated>2024-10-02T05:54:00.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Goals"><a href="#Goals" class="headerlink" title="Goals"></a>Goals</h2><ul><li><p><strong>每年至少学习一种新语言</strong></p><p>  不同语言以不同方式解决相同的问题。多学习几种不同的解决方法， 能帮助自己拓宽思维，避免陷入成规。此外，要感谢丰富的免费软件，让我们学习多种语言非常容易。</p></li><li><p><strong>每季度阅读一本技术书籍</strong></p><p>  虽然网络上有大量的短文和偶尔可靠的答案，但深入理解还是需要去读长篇的书。浏览书店页面后挑选和你当前项目主体相关的技术图书。一旦你养成习惯，就一个月读一本。在你掌握了当前正在使用的所有技术后，扩展你的领域，学习一些和你的项目不相关的东西。</p></li><li><p><strong>还要读非技术书</strong></p><p>  记住计算机是由人— —你在设法满足其需要的人——使用的，这十分重要。不要忘了等式中人这一边</p></li><li><p><strong>上课</strong></p><p>  在本地的学院或大学、或是将要来临的下一次会展上寻找有趣的课程。</p></li><li><p><strong>参加本地用户组织</strong></p><p>  不要只是去听讲，而要主动参与。与世隔绝对你的职业生涯来说可能是致命的;打听一下你们公司以外的人都在做什么。</p></li><li><p><strong>试验不同的环境</strong></p><p>  如果你只在Windows 上工作，就在家玩一玩Unix(可自由获取的Linux 就正好)。 如果你只用过makefile和编辑器，就试一试IDE，反之亦然。</p></li><li><p><strong>跟上潮流</strong></p><p>  订阅商务杂志和其他期刊。选择所涵盖的技术与你当前的项目不同的刊物</p></li><li><p><strong>上网</strong></p><p>  想要了解某种新语言或其他技术的各种特性?要了解其他人的相关经验，了解他们使用的特定行话，等等，新闻组是一种很好的方式。上网冲浪，查找论文、商业站点，以及其他任何你可以找到的信息来源</p></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="A-pragmatic-philosophy"><a href="#A-pragmatic-philosophy" class="headerlink" title="A pragmatic philosophy"></a>A pragmatic philosophy</h3><ul><li><p><strong>Provide Options, Don’t Make Lame Excuses 提供各种选择，不要找蹩脚的借口</strong></p><p>  如果你确实同意要为某个结果负责，你就应切实负起责任。当你犯错误(就如同我们所有人都 会犯错误一样)、或是判断失误时，诚实地承认它，并设法给出各种选择。不要责备别人或别的东西，或是拼凑借口。除了尽你所能以外，你必须分析风险是否超出了你的控制。</p></li><li><p><strong>Don’t Live with Broken Windows 不要容忍破窗户</strong></p><p>  不要留着“破窗户” (低劣的设计、错误决策、或是糟糕的代码)不修。发现一个就修一个。 如果没有足够的时间进行适当的修理，就用木板把它钉起来。或许你可以把出问题的代码放人注 释 (comment out)， 或是显示“未实现”消息 ，或是用虚设的数据(dummy data) 加以替代 。 采取某种行动防止进一步的损坏，并说明情势处在你的控制之下。</p></li><li><p><strong>Be a Catalyst for Change 做变化的催化剂</strong></p><p>  这正是拿出石头的时候。设计出你可以合理要求的东西，好好开发它。一旦完成，就拿给大家看，让他们大吃一惊。然后说:“要是我们增加…可能就会更好。”假装那并不重要。坐回椅子上，等着他们开始要你增加你本来就想要的功能。人们发现，参与正在发生的成功要更容易。 让他们瞥见未来，你就能让他们聚集在你周围’。</p></li><li><p><strong>Remember the Big Picture 记住大图景</strong></p><p>  我们没有做过这个—真的，但有人说，如果你抓一只青蛙放进沸水里，它会一下子跳出来。 但是，如果你把青蛙放进冷水里，然后慢慢加热，青蛙不会注意到温度的缓慢变化，会呆在锅里， 直到被煮熟。</p></li><li><p><strong>Make Quality a Requirements Issue 使质量成为需求问题</strong></p><p>  你常常会处在须要进行权衡的情形中。让人惊奇的是 ，许多用户宁愿在今天用上有一些 “ 毛 边” 的软件，也不愿等待 一年后的多媒体版本。许多预算吃紧的T部门都会同意这样的说法。 今天的了不起的软件常常比明天的完美软件更可取。如果你给用户某样东西，让他们及早使用， 他们的反馈常常会把你引向更好的最终解决方案</p></li><li><p><strong>Invest Regularly in Your Knowledge Portfolio 定期为你的知识资产投资</strong></p><p>  管理知识资产与管理金融资产非常相似：</p><ul><li>严肃的投资者定期投资——作为习惯<ul><li>就像金融投资一样，你必须定期为你的知识资产投资。即使投资量很小，习惯自身也和总量一样重要</li></ul></li><li>多元化是长期成功的关键<ul><li>你知道的不同的事情越多，你就越有价值。作为底线，你需要知道你目前所用的特 定技术的各种特性。但不要就此止步。计算技术的面貌变化很快— —今天的热门技术明天就可能变得近平无用(或至少是不再抢手)。你掌握的技术越多，你就越能更好地进行调整， 赶上变化 。</li></ul></li><li>聪明的投资者在保守的投资和高风险、高回报的投资之间平衡他们的资产<ul><li>从高风险、可能有高回报，到低风险、低回报，技术存在于这样一条谱带上。把 你所有的金钱都投入可能突然崩盘的高风险股票并不是 一个好主意;你也不应太保守，错过可能的机会。不要把你所有的技术鸡蛋放在一个篮子里</li></ul></li><li>投资者设法低买高卖，以获取最大回报<ul><li>在新兴的技术流行之前学习它可能就和找到被低估的股票—样困难，但所得到的 就和那样的股票带来的收益一样。在Java 刚出现时学习它可能有风险，但对于现在已步入该领域的顶尖行列的早期采用者，这样做得到了非常大的回报。</li></ul></li><li>应周期性的重新评估和平衡资产<ul><li>这是一个非常动荡的行业。你上个月开始研究的热门技术现在也许已像石头一样冰冷。也许你需要重温你有一阵子没有使用的数据库技术。又或许，如果你之前试用过另一种语言，你就会更有可能获得那个新职位……</li></ul></li></ul></li><li><p><strong>Critically Analyze What You Read and Hear 批判地分析你读到的和听到的</strong></p></li><li><p><strong>It’s Both What You Say and the Way You Say It 你说什么和你怎么说同样重要</strong></p></li></ul><h3 id="A-pragmatic-approach"><a href="#A-pragmatic-approach" class="headerlink" title="A pragmatic approach"></a>A pragmatic approach</h3><ul><li><p><strong>Make It Easy to Reuse 让复用变得容易</strong></p><p>  你所要做的是营造 一种环境，在其中要找到并复用已有的东西，比自己编写更容易。如果不容易，大家就不会去复用。而如果不进行复用，你们就会有重复知识的风险。</p></li><li><p><strong>Eliminate Effects Between Unrelated Things 消除无关事物之间的影响</strong></p><p>  如果你编写正交的系统，你得到两个主要好处:提高生产率与降低风险</p></li><li><p><strong>There Are No Final Decisions 不存在最终决策</strong></p><p>  错误在于假定决策是浇铸在石头上的— 同时还在于没有为可能出现的意外事件做准备。 要把决策视为是写在沙滩上的，而不要把它们刻在石头上。大浪随时可能到来，把它们抹去。</p></li><li><p><strong>Use Tracer Bullets to Find the Target 用曳光弹找到目标</strong></p><p>  曳光弹行之有效，是因为它们与真正的子弹在相同的环境、相同的约束下工作。它们快速飞 向目标，所以枪手可以得到即时的反馈。同时，从实践的角度看，这样的解决方案也更便宜。 为了在代码中获得同样的效果，我们要找到某种东西，让我们能快速、直观和可重复地从需求出发，满足最终系统的某个方面要求</p></li><li><p>Prototype to Learn 为了学习而制作原型<br>  在构建原型时，你可以忽略哪些细节？</p><ul><li>正确性：你也许可以在适当的地方使用虚设的数据</li><li>完整性：原型也许只能在非常有限的意义上工作，也许只有一项预先选择的输人数据和一个菜单项。</li><li>健壮性。错误检查很可能不完整，或是完全没有。如果你偏离预定路径，原型就可能崩溃， 并在“烟火般的灿烂显示中焚毁”。这没有关系。</li><li>风格。在纸上承认这一点让人痛苦，但原型代码可能没有多少注释或文档。根据使用原型的经验，你也许会撰写出大量文档，但关于原型系统自身的内容相对而言却非常少。</li></ul></li><li><p>Program Close to the Problem domain 靠近问题领域编程<br>  无论是用于配置和控制应用程序的简单语言，还是用于指定规则或过程的更为复杂的语言， 我们认为，你都应该考虑让你的项目更靠近问题领域。通过在更高的抽象层面上编码，你获得了 专心解决领域问题的自由，并且可以忽略琐碎的实现细节。<br>  记住，应用有许多用户。有最终用户，他们了解商业规则和所需输出;也有次级用户：操作人员、配置与测试管理人员、支持与维护程序员，还有将来的开发者。他们都有各自的问题领域， 而你可以为他们所有人生成小型环境和语言。</p></li><li><p>Estimate to Avoid Surprises 估算，以避免发生意外</p></li><li><p>Iterate the Schedule with the Code 通过代码对进度表进行迭代<br>  一 开始，你对需要多少次迭代、或是需要多少时间，也许只有模糊的概念。有些方法要求你 把这个作为初始计划的一部分定下来，但除了最微不足道的项目，这是 一个错误。除非你在开发与前一个应用类似的应用，拥有同样的团队和同样的技术，否则，你就只不过是在猜想。 于是你完成了初始功能的编码与测试，并将此标记为第 一轮增量开发的结束。基于这样的经 验，你可以提炼你原来对迭代次数，以及在每次选代中可以包含的内容的猜想。提炼会变得一次 比 一次好，对进度表的信心也将随之增长。</p></li></ul><h3 id="The-Basic-Tools"><a href="#The-Basic-Tools" class="headerlink" title="The Basic Tools"></a>The Basic Tools</h3><ul><li><p>Keep Knowledge in Plain Text 用纯文本保存知识</p></li><li><p>Use the Power of Command Shells 利用命令 shell 的力量</p></li><li><p>Use a Single Editor Well 用好一种编辑器<br>  选一种编辑器，彻底了解它 ，并将其用于所有的编辑任务。如果你用一种编辑器(或一组键 绑定)进行所有的文本编辑活动，你就不必停下来思考怎样完成文本操纵:必需的键击将成为本能反应。编辑器将成为你双手的延伸;键会在滑过文本和思想时歌唱起来。这就是我们的目标。</p></li><li><p>Always Use Source Code Control 总是使用源码控制<br>  总是。即使你的团队只有你一个人，你的项目只需一周时间;即使那是“用过就扔” 的原型; 即使你的工作对象并非源码;确保每样东西都处在源码控制之下——文档、电话号码表、给供应商的备忘录、makefie、构建与发布流程、烧制CD母盘的shell小脚本— 每样东西。我们例行 公事地对我们敲人的每一样东西进行源码控制(包括本书的文本)。即使我们不是在开发项目， 我们的日常工作也被安全地保存在仓库中。</p></li><li><p>Fix the Problem, Not the Blame 要修正问题，而不是发出指责<br>  发现了他人的bug之后，你可以花费时间和精力去指责让人厌恶的肇事者。在有些工作环境 中，这是文化的一部分，并且可能是“疏通剂”。但是，在技术竞技场上，你应该专注于修正问题，而不是发出指责。</p></li><li><p>Don’t Panic 不要恐慌<br>  人很容易恐慌，特别是如果你正面临最后期限的到来、或是正在设法找出bug的原因，有一个神经质的老板或客户在你的脖子后面喘气。但非常重要的事情是，要后退一步，实际思考什么可能造成你认为表征了bug的那些症状。</p></li><li><p>“Select” Isn’t Broken “Select 没有问题”<br>  我们参加过一个项目的开发，有位高级工程师确信select 系统调用在Solaris 上有问题。再多 的劝说或逻辑也无法改变他的想法(这台机器上的所有其他网络应用都工作良好这一事实也一样无济于事)。他花了数周时间编写绕开这一问题的代码，因为某种奇怪的原因，却好像并没有解决问题。当最后被迫坐下来、阅读关于select 的文档时，他在几分钟之内就发现并纠正了问题。&#x3D;&#x3D;&#x3D;&#x3D;现在每当有人开始因为很可能是我们自己的故障而抱怨系统时，我们就会使用“select 没有问题” 作为温和的提醒。&#x3D;&#x3D;&#x3D;&#x3D;</p><p>  如果你“只改动了一样东西”，系统就停止了工作，那样东西很可能就需要对此负责— 直接地或间接地，不管那看起来有多牵强。有时被改动的东西在你的控制之外 :OS 的新版本、编译器、数据库或是其他第三方软件都可能会毁坏先前的正确代码 。可能会出现新的bug。你先前 已绕开的bug得到了修正，却破坏了用于绕开它的代码。API 变了，功能变了;简而言之，这是全新的局面，你必须在这些新的条件下重新测试系统。所以在考虑升级时要紧盯着进度表;你可能会想等到下一次发布之后再升级。</p></li><li><p>Don’t Assume it —— Prove It 不要假定，要证明<br>  某样东西出错时，你感到吃惊的程度与你对正在运行的代码的信任及信心成正比。 这就是为什么，在面对“让人吃惊” 的故障时，你必须意识到你的 一个或更多的假设是错的。不 要因为你“知道” 它能工作而轻易放过与bug有牵连的例程或代码。证明它。用这些数据、这些边界条件、在这个语境中证明它。</p></li><li><p>Learn a Text Manipulation Language 学习一种文本操纵语言</p></li><li><p>Write Code That Writes Code 编写能编写代码的代码<br>  被动代码生成器只运行 一次来生成结果。然后结果就变成了独立的— 它与代码生成器分离 了。<br>  主动代码生成器在每次需要其结果时被使用。结果是用过就扔的——它总是能由代码生成器重新生成。主动代码生成器为了生成其结果，常常要读取某种形式的脚本或控制文件。</p></li></ul><h3 id="Pragmatic-Paranoia"><a href="#Pragmatic-Paranoia" class="headerlink" title="Pragmatic Paranoia"></a>Pragmatic Paranoia</h3><ul><li><p>You Can’t Write Perfect Software 你不可能写出完美的软件</p></li><li><p>Design with Contracts 通过合约进行设计</p></li><li><p>Crash Early 早崩溃<br>  我们很容易掉进“它不可能发生” 这样 —种心理状态。我们中的大多数人编写的代码都不检 查文件是否能成功关闭，或者某个跟踪语句是否已按照我们的预期写出。而如果所有的事情都能 如我们所愿，我们很可能就不需要那么做— 这些代码在任何正常的条件都不会失败。但我们是 在防卫性地编程，我们在程序的其他部分中查找破坏堆栈的“淘气指针”，我们在检查确实加载了共享库的正确版本。<br>  所有的错误都能为你提供信息。你可以让自己相信错误不可能发生，并选择忽略它。但与此 相反，注重实效的程序员告诉自己，如果有 一个错误，就说明非常、非常糟糕的事情已经发生了。</p></li><li><p>If It Can’t Happen, Use Assertions to Ensure That It Won’t 如果他不可能发生，用断言确保他不会发生</p></li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><blockquote><p>这是痛苦的事：<br>看着你自己的烦忧，并且知道<br>不是别人，而是你自己一人所致<br>——索福克勒斯：《埃阿斯》</p></blockquote><h3 id="调试的心理学"><a href="#调试的心理学" class="headerlink" title="调试的心理学"></a>调试的心理学</h3><p>要接受事实:调试就是解决问题，要据此发起进攻。<br>bug 是你的过错还是别人的过错，并不是真的很有关系。它仍然是你的问题。</p><h3 id="调试的思维方式"><a href="#调试的思维方式" class="headerlink" title="调试的思维方式"></a>调试的思维方式</h3><blockquote><p>最容易欺骗的人就是自己<br>—— Edward Bulwer-Lytton, <em>The Disowned</em></p></blockquote><p>在你开始调试之前，选择恰当的思维方式十分重要。你须要关闭每天用于保护自我(ego) 的许多防卫措施，忘掉你可能面临的任何项目压力，并让自己放松下来。</p><p>在调试时小心“近视”。要抵制只修正你看到的症状的急迫愿望:更有可能的情况是，实际 的故障离你正在观察的地方可能还有几步远，并且可能涉及许多其他的相关事物。要总是设法找 出问题的根源，而不只是问题的特定表现。</p><h3 id="从何处开始"><a href="#从何处开始" class="headerlink" title="从何处开始"></a>从何处开始</h3><p>在开始查看bug之前，要确保你是在能够成功编译的代码上工作——没有警告。我们例行公 事地把编译器警告级设得尽可能高。把时间浪费在设法找出编译器能够为你找出的问题上没有意义!我们需要专注于手上更困难的问题。</p><ul><li>你也许需要与报告bug 的用户面谈，以搜集比最初给你的数据更多的数据 </li><li>人工合成的测试不能足够地演练 (exercise)应用 。 你必须既强硬地测试边界条件，又测试现实中的最终用户的使用模式。你需要系统地进行这样的测试。</li></ul><h3 id="造成惊讶的要素"><a href="#造成惊讶的要素" class="headerlink" title="造成惊讶的要素"></a>造成惊讶的要素</h3><p>当你遇到让人吃惊的bug时，除了只是修正它而外，你还需要确定先前为什么没有找出这个 故障。考虑你是否需要改进单元测试或其他测试，以让它们有能力找出这个故障。</p><p>还有，如果bug是一些坏数据的结果，这些数据在造成爆发之前传播通过了若千层面，看一 看在这些例程中进行更好的参数检查是否能更早地隔离它。</p><p>在你对其进行处理的同时，代码中是否有任何其他地方容易受这同 一个bug的影响?现在就是 找出并修正它们的时机。确保无论发生什么，你都知道它是否会再次发生。</p><p>如果修正这个bug需要很长时间，问问你自己为什么。你是否可以做点什么，让下一次修正 这个bug变得更容易?也许你可以内建更好的测试挂钩，或是编写日志文件分析器。 </p><p>最后，如果bug 是某人的错误假定的结果，与整个团队一起讨论这个问题。如果 一个人有误 解，那么许多人可能也有。</p><p>去做所有这些事情，下一次你就将很有希望不再吃惊。</p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p>下面是一些你可以在架构原型中寻求解答的具体问题:</p><ul><li>主要组件的责任是否得到了良好定义?是否适当?</li><li>主要组件间的协作是否得到了良好定义?</li><li>耦合是否得以最小化?</li><li>你能否确定重复的潜在来源?</li><li>接又定义和各项约束是否可接受?</li><li>每个模块在执行过程中是否能访问到其所需的数据?是否能在需要时进行访问?<br>根据我们制作原型的经验，最后一项往往会产生最让人惊讶和最有价值的结果。</li></ul><table><thead><tr><th>如果这听起来像你…</th><th>那么考虑…</th></tr></thead><tbody><tr><td>我使用许多不同的编辑器，但只使用其基本特性</td><td>选一种强大的编辑器，好好学习他</td></tr><tr><td>我有最喜欢的编辑器，但不使用其全部特性</td><td>学习他们。减少你需要敲击的键数</td></tr><tr><td>我有最喜欢的编辑器，只要可能就使用它</td><td>设法扩展它，并将其用于比现在更多的任务</td></tr></tbody></table><h3 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h3><p>无论何时你发现自己在设法让两种完全不同的环境 一起工作，你都应该考虑使用主动代码生 成器。</p><h3 id="按合约设计"><a href="#按合约设计" class="headerlink" title="按合约设计"></a>按合约设计</h3><ul><li>前条件：为了调用例程，必须为真的条件;例程的需求。在其前条件被违反时 ，例程决不应被调用 。传递好数据是调用者的责任。</li><li>后条件： 例程保证会做的事情，例程完成时世界的状态。例程有后条件这一事实意味着它会结束 :不允许有无限循环。</li><li>类不变项 (class invariant)。类确保从调用者的视角来看，该条件总是为真。在例程的内部处理过程中，不变项不一定会保持，但在例程退出、控制返回到调用者时，不变项必须为真 (注意，类不能给出无限制的对参与不变项的任何数据成员的写访问)。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Goals&quot;&gt;&lt;a href=&quot;#Goals&quot; class=&quot;headerlink&quot; title=&quot;Goals&quot;&gt;&lt;/a&gt;Goals&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;每年至少学习一种新语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  不同语言以不同方式解决</summary>
      
    
    
    
    <category term="The Pragmatic Programmer" scheme="http://example.com/categories/The-Pragmatic-Programmer/"/>
    
    
    <category term="book" scheme="http://example.com/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>How to read paper</title>
    <link href="http://example.com/2022/10/25/paper/How%20to%20read%20paper/"/>
    <id>http://example.com/2022/10/25/paper/How%20to%20read%20paper/</id>
    <published>2022-10-25T03:40:36.000Z</published>
    <updated>2024-10-02T08:38:55.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><ul><li>title</li><li>abstract</li><li>introduction</li><li>method</li><li>experiment</li><li>conclusion</li></ul><h2 id="Pass-1"><a href="#Pass-1" class="headerlink" title="Pass 1"></a>Pass 1</h2><p>title——是否相关？<br>abstract——论文在做什么？<br>conclusion</p><p>略看论文的图和表<br>论文在大概讲什么东西，方法怎么样，结果怎么样，是否适合自己？</p><h2 id="Pass-2"><a href="#Pass-2" class="headerlink" title="Pass 2"></a>Pass 2</h2><p>主要关注重点的图和表<br>相关的重要文献标记</p><p>继续思考论文的质量以及和自己研究方向的契合程度，决定一下要不要进行第三遍的完完全全彻底的精读。</p><h2 id="Pass-3"><a href="#Pass-3" class="headerlink" title="Pass 3"></a>Pass 3</h2><p>代入自己去思考如果要是我来写这篇文章，我会如何组织这个结构？读实验部分的时候，可以思考一下，作者是如何描述自己的实验的，你可以思考，如果换自己来做的话，能不能比作者做得更好？ 这一遍读的时候，一定要明白作者每句话，每个字在说什么，并且最好可以脑补出它整个流程是什么样子的，似乎是自己在做实验，写论文一样。如果有困难的话，可以借助思维导图或者流程图这样的工具，把他的整个流程以可视化的形式展现出来，帮助自己理解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Structure&quot;&gt;&lt;a href=&quot;#Structure&quot; class=&quot;headerlink&quot; title=&quot;Structure&quot;&gt;&lt;/a&gt;Structure&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;title&lt;/li&gt;
&lt;li&gt;abstract&lt;/li&gt;
&lt;li&gt;int</summary>
      
    
    
    
    
    <category term="paper" scheme="http://example.com/tags/paper/"/>
    
  </entry>
  
</feed>
